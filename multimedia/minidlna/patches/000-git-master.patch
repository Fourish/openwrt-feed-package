--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,14 @@
+1.1.6 - Released 16-June-2016
+--------------------------------
+- Add AllShare and Windows client detection.
+- Update support for LG2012 TV.
+- Fix Samsung bookmarking on magic containers.
+- Fix SQL error when moving captions.
+- Add wide_links config option.
+- Fix external subtitles on Samsung Series J.
+- Add string localization support for magic containers.
+- Rework NLS init to work with non-en_US locales.
+
 1.1.5 - Released 10-Sep-2015
 --------------------------------
 - Re-enable Samsung DCM10, which adds video bookmarks and "BasicView" support.
--- a/clients.c
+++ b/clients.c
@@ -53,6 +53,16 @@ struct client_type_s client_types[] =
 	  EXAVClientInfo
 	},
 
+	/* User-Agent: DLNADOC/1.50 SEC_HHP_[PC]LPC001/1.0  MS-DeviceCaps/1024 */
+	/* This is AllShare running on a PC.  We don't want to respond with Samsung
+	 * capabilities, or Windows (and AllShare) might get grumpy. */
+	{ 0,
+	  FLAG_DLNA,
+	  "AllShare",
+	  "SEC_HHP_[PC]",
+	  EUserAgent
+	},
+
 	/* Samsung Series [CDE] BDPs and TVs must be separated, or some of our
 	 * advertised extra features trigger a folder browsing bug on BDPs. */
 	/* User-Agent: DLNADOC/1.50 SEC_HHP_BD-D5100/1.0 */
@@ -65,9 +75,10 @@ struct client_type_s client_types[] =
 
 	/* User-Agent: DLNADOC/1.50 SEC_HHP_[TV]UE40D7000/1.0 */
 	/* User-Agent: DLNADOC/1.50 SEC_HHP_ Family TV/1.0 */
+	/* USER-AGENT: DLNADOC/1.50 SEC_HHP_[TV] UE65JU7000/1.0 UPnP/1.0 */
 	{ ESamsungSeriesCDE,
-	  FLAG_SAMSUNG | FLAG_DLNA | FLAG_NO_RESIZE | FLAG_SAMSUNG_DCM10,
-	  "Samsung Series [CDEF]",
+	  FLAG_SAMSUNG | FLAG_DLNA | FLAG_NO_RESIZE | FLAG_SAMSUNG_DCM10 | FLAG_CAPTION_RES,
+	  "Samsung Series [CDEFJ]",
 	  "SEC_HHP_",
 	  EUserAgent
 	},
@@ -134,6 +145,14 @@ struct client_type_s client_types[] =
 	  EXAVClientInfo
 	},
 
+	/* USER-AGENT: Linux/2.6.35 UPnP/1.0 DLNADOC/1.50 INTEL_NMPR/2.0 LGE_DLNA_SDK/1.6.0 */
+	{ ELGNetCastDevice,
+	  FLAG_DLNA | FLAG_CAPTION_RES,
+	  "LG",
+	  "LGE_DLNA_SDK/1.6.0",
+	  EUserAgent
+	},
+
 	/* User-Agent: Linux/2.6.31-1.0 UPnP/1.0 DLNADOC/1.50 INTEL_NMPR/2.0 LGE_DLNA_SDK/1.5.0 */
 	{ ELGDevice,
 	  FLAG_DLNA | FLAG_CAPTION_RES,
@@ -221,6 +240,13 @@ struct client_type_s client_types[] =
 	  EUserAgent
 	},
 
+	{ 0,
+	  FLAG_DLNA | FLAG_MIME_AVI_AVI,
+	  "Windows",
+	  "FDSSDP",
+	  EUserAgent
+	},
+
 	{ EStandardDLNA150,
 	  FLAG_DLNA | FLAG_MIME_AVI_AVI,
 	  "Generic DLNA 1.5",
--- a/clients.h
+++ b/clients.h
@@ -57,6 +57,7 @@ enum client_types {
 	EDirecTV,
 	EFreeBox,
 	ELGDevice,
+	ELGNetCastDevice,
 	ELifeTab,
 	EMarantzDMP,
 	EMediaRoom,
--- a/configure.ac
+++ b/configure.ac
@@ -575,7 +575,6 @@ AC_ARG_ENABLE(readynas,
 		AC_DEFINE([NETGEAR],[1],[Define to 1 if you want to enable generic NETGEAR device support])
 		AC_DEFINE([READYNAS],[1],[Define to 1 if you want to enable NETGEAR ReadyNAS support])
 		AC_DEFINE([TIVO_SUPPORT], 1, [Define to 1 if you want to enable TiVo support])
-		AC_DEFINE([PNPX],[5],[Define to 5 if you want to enable NETGEAR ReadyNAS PnP-X support])
 		AC_DEFINE_UNQUOTED([OS_URL],"http://www.readynas.com/")
 		AC_DEFINE_UNQUOTED([ROOTDEV_MANUFACTURERURL],"http://www.netgear.com/")
 		AC_DEFINE_UNQUOTED([ROOTDEV_MANUFACTURER],"NETGEAR")
--- a/inotify.c
+++ b/inotify.c
@@ -25,6 +25,7 @@
 #include <unistd.h>
 #include <dirent.h>
 #include <libgen.h>
+#include <signal.h>
 #include <errno.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -349,9 +350,8 @@ inotify_insert_file(char * name, const c
 			if( !is_image(path) )
 				return -1;
 			break;
-                default:
+		default:
 			return -1;
-			break;
 	}
 	
 	/* If it's already in the database and hasn't been modified, skip it. */
@@ -641,7 +641,7 @@ inotify_remove_directory(int fd, const c
 }
 
 void *
-start_inotify()
+start_inotify(void)
 {
 	struct pollfd pollfds[1];
 	int timeout = 1000;
@@ -650,6 +650,10 @@ start_inotify()
 	int length, i = 0;
 	char * esc_name = NULL;
 	struct stat st;
+	sigset_t set;
+
+	sigfillset(&set);
+	pthread_sigmask(SIG_BLOCK, &set, NULL);
         
 	pollfds[0].fd = inotify_init();
 	pollfds[0].events = POLLIN;
--- a/metadata.c
+++ b/metadata.c
@@ -149,7 +149,7 @@ check_for_captions(const char *path, int
 
 	if (ret == 0)
 	{
-		sql_exec(db, "INSERT into CAPTIONS"
+		sql_exec(db, "INSERT OR REPLACE into CAPTIONS"
 		             " (ID, PATH) "
 		             "VALUES"
 		             " (%lld, %Q)", detailID, file);
--- a/minidlna.c
+++ b/minidlna.c
@@ -238,30 +238,6 @@ getfriendlyname(char *buf, int len)
 		}
 	}
 	fclose(info);
-#if PNPX
-	memcpy(pnpx_hwid+4, "01F2", 4);
-	if (strcmp(modelnumber, "NVX") == 0)
-		memcpy(pnpx_hwid+17, "0101", 4);
-	else if (strcmp(modelnumber, "Pro") == 0 ||
-	         strcmp(modelnumber, "Pro 6") == 0 ||
-	         strncmp(modelnumber, "Ultra 6", 7) == 0)
-		memcpy(pnpx_hwid+17, "0102", 4);
-	else if (strcmp(modelnumber, "Pro 2") == 0 ||
-	         strncmp(modelnumber, "Ultra 2", 7) == 0)
-		memcpy(pnpx_hwid+17, "0103", 4);
-	else if (strcmp(modelnumber, "Pro 4") == 0 ||
-	         strncmp(modelnumber, "Ultra 4", 7) == 0)
-		memcpy(pnpx_hwid+17, "0104", 4);
-	else if (strcmp(modelnumber+1, "100") == 0)
-		memcpy(pnpx_hwid+17, "0105", 4);
-	else if (strcmp(modelnumber+1, "200") == 0)
-		memcpy(pnpx_hwid+17, "0106", 4);
-	/* 0107 = Stora */
-	else if (strcmp(modelnumber, "Duo v2") == 0)
-		memcpy(pnpx_hwid+17, "0108", 4);
-	else if (strcmp(modelnumber, "NV+ v2") == 0)
-		memcpy(pnpx_hwid+17, "0109", 4);
-#endif
 #else
 	char * logname;
 	logname = getenv("LOGNAME");
@@ -468,9 +444,21 @@ static int strtobool(const char *str)
 static void init_nls(void)
 {
 #ifdef ENABLE_NLS
-	setlocale(LC_MESSAGES, "");
-	setlocale(LC_CTYPE, "en_US.utf8");
-	DPRINTF(E_DEBUG, L_GENERAL, "Using locale dir %s\n", bindtextdomain("minidlna", getenv("TEXTDOMAINDIR")));
+	const char *messages, *ctype, *locale_dir;
+
+	ctype = setlocale(LC_CTYPE, "");
+	if (!ctype || !strcmp(ctype, "C"))
+		ctype = setlocale(LC_CTYPE, "en_US.utf8");
+	if (!ctype)
+		DPRINTF(E_WARN, L_GENERAL, "Unset locale\n");
+	else if (!strstr(ctype, "utf8") && !strstr(ctype, "UTF8") &&
+		 !strstr(ctype, "utf-8") && !strstr(ctype, "UTF-8"))
+		DPRINTF(E_WARN, L_GENERAL, "Using unsupported non-utf8 locale '%s'\n", ctype);
+	messages = setlocale(LC_MESSAGES, "");
+	if (!messages)
+		messages = "unset";
+	locale_dir = bindtextdomain("minidlna", getenv("TEXTDOMAINDIR"));
+	DPRINTF(E_DEBUG, L_GENERAL, "Using locale dir '%s' and locale langauge %s/%s\n", locale_dir, messages, ctype);
 	textdomain("minidlna");
 #endif
 }
@@ -738,6 +726,10 @@ init(int argc, char **argv)
 			if (strtobool(ary_options[i].value))
 				SETFLAG(MERGE_MEDIA_DIRS_MASK);
 			break;
+		case WIDE_LINKS:
+			if (strtobool(ary_options[i].value))
+				SETFLAG(WIDE_LINKS_MASK);
+			break;
 		default:
 			DPRINTF(E_ERROR, L_GENERAL, "Unknown option in file %s\n",
 				optionsfile);
@@ -1021,11 +1013,11 @@ main(int argc, char **argv)
 
 	for (i = 0; i < L_MAX; i++)
 		log_level[i] = E_WARN;
-	init_nls();
 
 	ret = init(argc, argv);
 	if (ret != 0)
 		return 1;
+	init_nls();
 
 	DPRINTF(E_WARN, L_GENERAL, "Starting " SERVER_NAME " version " MINIDLNA_VERSION ".\n");
 	if (sqlite3_libversion_number() < 3005001)
@@ -1299,10 +1291,6 @@ shutdown:
 	if (scanning && scanner_pid)
 		kill(scanner_pid, SIGKILL);
 
-	/* kill other child processes */
-	process_reap_children();
-	free(children);
-
 	/* close out open sockets */
 	while (upnphttphead.lh_first != NULL)
 	{
@@ -1330,6 +1318,10 @@ shutdown:
 	if (inotify_thread)
 		pthread_join(inotify_thread, NULL);
 
+	/* kill other child processes */
+	process_reap_children();
+	free(children);
+
 	sql_exec(db, "UPDATE SETTINGS set VALUE = '%u' where KEY = 'UPDATE_ID'", updateID);
 	sqlite3_close(db);
 
--- a/minidlna.conf
+++ b/minidlna.conf
@@ -81,3 +81,6 @@ model_number=1
 # maximum number of simultaneous connections
 # note: many clients open several simultaneous connections while streaming
 #max_connections=50
+
+# set this to yes to allow symlinks that point outside user-defined media_dirs.
+#wide_links=no
--- a/minidlna.conf.5
+++ b/minidlna.conf.5
@@ -163,6 +163,10 @@ force_sort_criteria=+upnp:class,+upnp:or
 
 .fi
 
+.IP "\fBwide_links\fP"
+Set to 'yes' to allow symlinks that point outside user-defined media_dirs.
+By default, wide symlinks are not followed.
+
 
 
 .SH VERSION
--- a/options.c
+++ b/options.c
@@ -64,7 +64,8 @@ static const struct {
 	{ USER_ACCOUNT, "user" },
 	{ FORCE_SORT_CRITERIA, "force_sort_criteria" },
 	{ MAX_CONNECTIONS, "max_connections" },
-	{ MERGE_MEDIA_DIRS, "merge_media_dirs" }
+	{ MERGE_MEDIA_DIRS, "merge_media_dirs" },
+	{ WIDE_LINKS, "wide_links" }
 };
 
 int
--- a/options.h
+++ b/options.h
@@ -57,7 +57,8 @@ enum upnpconfigoptions {
 	USER_ACCOUNT,			/* user account to run as */
 	FORCE_SORT_CRITERIA,		/* force sorting by a given sort criteria */
 	MAX_CONNECTIONS,		/* maximum number of simultaneous connections */
-	MERGE_MEDIA_DIRS		/* don't add an extra directory level when there are multiple media dirs */
+	MERGE_MEDIA_DIRS,		/* don't add an extra directory level when there are multiple media dirs */
+	WIDE_LINKS			/* allow following symlinks outside the defined media_dirs */
 };
 
 /* readoptionsfile()
--- a/po/da.po
+++ b/po/da.po
@@ -68,6 +68,10 @@ msgstr "Mapper"
 msgid "Playlists"
 msgstr "Afspilningslister"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "Nylig tilføjet"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Film"
--- a/po/de.po
+++ b/po/de.po
@@ -83,6 +83,10 @@ msgstr "Ordner"
 msgid "Playlists"
 msgstr "Wiedergabelisten"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "Kürzlich hinzugefügt"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Video"
--- a/po/es.po
+++ b/po/es.po
@@ -68,6 +68,10 @@ msgstr "Carpetas"
 msgid "Playlists"
 msgstr "Listas"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "Recientemente añadido"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Vídeo"
--- a/po/fr.po
+++ b/po/fr.po
@@ -68,6 +68,10 @@ msgstr "Dossiers"
 msgid "Playlists"
 msgstr "Liste de lecture"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "Ajouts récents"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Vidéo"
--- a/po/it.po
+++ b/po/it.po
@@ -70,6 +70,10 @@ msgstr "Cartelle"
 msgid "Playlists"
 msgstr "Scalette"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "Aggiunto recentemente"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Video"
--- a/po/ja.po
+++ b/po/ja.po
@@ -68,6 +68,10 @@ msgstr "フォルダ"
 msgid "Playlists"
 msgstr "プレイリスト"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "最近追加された"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "ビデオ"
--- a/po/ko.po
+++ b/po/ko.po
@@ -68,6 +68,10 @@ msgstr "폴더"
 msgid "Playlists"
 msgstr "재생 목록"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "최근에 추가"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "비디오"
--- a/po/minidlna.pot
+++ b/po/minidlna.pot
@@ -84,6 +84,10 @@ msgstr ""
 msgid "Playlists"
 msgstr ""
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr ""
+
 #: scanner.c:536
 msgid "Video"
 msgstr ""
--- a/po/nb.po
+++ b/po/nb.po
@@ -68,6 +68,10 @@ msgstr "Mapper"
 msgid "Playlists"
 msgstr "Spillelister"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "Nylig lagt til"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Video"
--- a/po/nl.po
+++ b/po/nl.po
@@ -68,6 +68,10 @@ msgstr "Mappen"
 msgid "Playlists"
 msgstr "Afspeellijst"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "Nyligen tillagd"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Video"
--- a/po/pl.po
+++ b/po/pl.po
@@ -83,6 +83,10 @@ msgstr "Folder"
 msgid "Playlists"
 msgstr "Lista Utworow"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "Niedawno dodane"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Filmy"
--- a/po/ru.po
+++ b/po/ru.po
@@ -85,6 +85,10 @@ msgstr "Папки"
 msgid "Playlists"
 msgstr "Списки Воспроизведения"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr ""
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Видео"
--- a/po/sl.po
+++ b/po/sl.po
@@ -83,6 +83,10 @@ msgstr "Mape"
 msgid "Playlists"
 msgstr "Seznami predvajanj"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "nedavno dodano"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Video"
--- a/po/sv.po
+++ b/po/sv.po
@@ -68,6 +68,10 @@ msgstr "Mappar"
 msgid "Playlists"
 msgstr "Spelningslistor"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "nyligen tillagda"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Film"
--- a/process.c
+++ b/process.c
@@ -96,10 +96,10 @@ process_fork(struct client_cache_s *clie
 	pid_t pid = fork();
 	if (pid > 0)
 	{
-		number_of_children++;
 		if (client)
 			client->connections++;
 		add_process_info(pid, client);
+		number_of_children++;
 	}
 
 	return pid;
--- a/scanner.c
+++ b/scanner.c
@@ -594,7 +594,8 @@ CreateDatabase(void)
 			ret = sql_exec(db, "INSERT into OBJECTS (OBJECT_ID, PARENT_ID, DETAIL_ID, CLASS, NAME)"
 			                   " values "
 					   "('%s', '%s', %lld, 'container.storageFolder', '%q')",
-					   magic->objectid_match, parent, GetFolderMetadata(magic->name, NULL, NULL, NULL, 0), magic->name);
+					   magic->objectid_match, parent,
+					   GetFolderMetadata(_(magic->name), NULL, NULL, NULL, 0), _(magic->name));
 			free(parent);
 			if( ret != SQLITE_OK )
 				goto sql_failed;
--- a/testupnpdescgen.c
+++ b/testupnpdescgen.c
@@ -40,9 +40,6 @@ char modelname[] = "MiniDLNA";
 char modelnumber[] = "1";
 char presentationurl[] = "http://192.168.0.1:8080/";
 unsigned int updateID = 0;
-#if PNPX
-char pnpx_hwid[] = "VEN_01F2&amp;DEV_0101&amp;REV_01 VEN_0033&amp;DEV_0001&amp;REV_01";
-#endif
 
 int getifaddr(const char * ifname, char * buf, int len)
 {
--- a/upnpdescgen.c
+++ b/upnpdescgen.c
@@ -115,29 +115,17 @@ static const char xmlver[] =
 static const char root_service[] =
 	"scpd xmlns=\"urn:schemas-upnp-org:service-1-0\"";
 static const char root_device[] = 
-	"root xmlns=\"urn:schemas-upnp-org:device-1-0\""
-#if PNPX
-	" xmlns:pnpx=\"http://schemas.microsoft.com/windows/pnpx/2005/11\""
-	" xmlns:df=\"http://schemas.microsoft.com/windows/2008/09/devicefoundation\""
-#endif
-	;
+	"root xmlns=\"urn:schemas-upnp-org:device-1-0\"";
 
 /* root Description of the UPnP Device */
 static const struct XMLElt rootDesc[] =
 {
 	{root_device, INITHELPER(1,2)},
 	{"specVersion", INITHELPER(3,2)},
-	{"device", INITHELPER(5,(14+PNPX))},
+	{"device", INITHELPER(5,(14))},
 	{"/major", "1"},
 	{"/minor", "0"},
 	{"/deviceType", "urn:schemas-upnp-org:device:MediaServer:1"},
-#if PNPX == 5
-	{"/pnpx:X_hardwareId", pnpx_hwid},
-	{"/pnpx:X_compatibleId", "MS_DigitalMediaDeviceClass_DMS_V001"},
-	{"/pnpx:X_deviceCategory", "MediaDevices"},
-	{"/df:X_deviceCategory", "Multimedia.DMS"},
-	{"/microsoft:magicPacketWakeSupported xmlns:microsoft=\"urn:schemas-microsoft-com:WMPNSS-1-0\"", "0"},
-#endif
 	{"/friendlyName", friendly_name},	/* required */
 	{"/manufacturer", ROOTDEV_MANUFACTURER},		/* required */
 	{"/manufacturerURL", ROOTDEV_MANUFACTURERURL},	/* optional */
@@ -149,12 +137,12 @@ static const struct XMLElt rootDesc[] =
 	{"/UDN", uuidvalue},	/* required */
 	{"/dlna:X_DLNADOC xmlns:dlna=\"urn:schemas-dlna-org:device-1-0\"", "DMS-1.50"},
 	{"/presentationURL", presentationurl},	/* recommended */
-	{"iconList", INITHELPER((19+PNPX),4)},
-	{"serviceList", INITHELPER((43+PNPX),3)},
-	{"icon", INITHELPER((23+PNPX),5)},
-	{"icon", INITHELPER((28+PNPX),5)},
-	{"icon", INITHELPER((33+PNPX),5)},
-	{"icon", INITHELPER((38+PNPX),5)},
+	{"iconList", INITHELPER((19),4)},
+	{"serviceList", INITHELPER((43),3)},
+	{"icon", INITHELPER((23),5)},
+	{"icon", INITHELPER((28),5)},
+	{"icon", INITHELPER((33),5)},
+	{"icon", INITHELPER((38),5)},
 	{"/mimetype", "image/png"},
 	{"/width", "48"},
 	{"/height", "48"},
@@ -175,9 +163,9 @@ static const struct XMLElt rootDesc[] =
 	{"/height", "120"},
 	{"/depth", "24"},
 	{"/url", "/icons/lrg.jpg"},
-	{"service", INITHELPER((46+PNPX),5)},
-	{"service", INITHELPER((51+PNPX),5)},
-	{"service", INITHELPER((56+PNPX),5)},
+	{"service", INITHELPER((46),5)},
+	{"service", INITHELPER((51),5)},
+	{"service", INITHELPER((56),5)},
 	{"/serviceType", "urn:schemas-upnp-org:service:ContentDirectory:1"},
 	{"/serviceId", "urn:upnp-org:serviceId:ContentDirectory"},
 	{"/controlURL", CONTENTDIRECTORY_CONTROLURL},
@@ -584,10 +572,10 @@ genRootDescSamsung(int * len)
 	memcpy(str, xmlver, *len + 1);
 	/* Replace the optional modelURL and manufacturerURL fields with Samsung foo */
 	memcpy(&samsungRootDesc, &rootDesc, sizeof(rootDesc));
-	samsungRootDesc[8+PNPX].eltname = "/sec:ProductCap";
-	samsungRootDesc[8+PNPX].data = "smi,DCM10,getMediaInfo.sec,getCaptionInfo.sec";
-	samsungRootDesc[12+PNPX].eltname = "/sec:X_ProductCap";
-	samsungRootDesc[12+PNPX].data = "smi,DCM10,getMediaInfo.sec,getCaptionInfo.sec";
+	samsungRootDesc[8].eltname = "/sec:ProductCap";
+	samsungRootDesc[8].data = "smi,DCM10,getMediaInfo.sec,getCaptionInfo.sec";
+	samsungRootDesc[12].eltname = "/sec:X_ProductCap";
+	samsungRootDesc[12].data = "smi,DCM10,getMediaInfo.sec,getCaptionInfo.sec";
 	str = genXML(str, len, &tmplen, samsungRootDesc);
 	str[*len] = '\0';
 	return str;
--- a/upnpglobalvars.c
+++ b/upnpglobalvars.c
@@ -66,9 +66,6 @@ char uuidvalue[] = "uuid:00000000-0000-0
 char modelname[MODELNAME_MAX_LEN] = ROOTDEV_MODELNAME;
 char modelnumber[MODELNUMBER_MAX_LEN] = MINIDLNA_VERSION;
 char serialnumber[SERIALNUMBER_MAX_LEN] = "00000000";
-#if PNPX
-char pnpx_hwid[] = "VEN_0000&amp;DEV_0000&amp;REV_01 VEN_0033&amp;DEV_0001&amp;REV_01";
-#endif
 
 /* presentation url :
  * http://nnn.nnn.nnn.nnn:ppppp/  => max 30 bytes including terminating 0 */
--- a/upnpglobalvars.h
+++ b/upnpglobalvars.h
@@ -57,7 +57,7 @@
 
 #include <sqlite3.h>
 
-#define MINIDLNA_VERSION "1.1.5"
+#define MINIDLNA_VERSION "1.1.6"
 
 #ifdef NETGEAR
 # define SERVER_NAME "ReadyDLNA"
@@ -75,10 +75,6 @@
 #endif
 #define THISORNUL(s) (s ? s : "")
 
-#ifndef PNPX
-#define PNPX 0
-#endif
-
 #define RESOURCE_PROTOCOL_INFO_VALUES \
 	"http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_TN," \
 	"http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_SM," \
@@ -191,6 +187,7 @@ extern uint32_t runtime_flags;
 #define NO_PLAYLIST_MASK      0x0008
 #define SYSTEMD_MASK          0x0010
 #define MERGE_MEDIA_DIRS_MASK 0x0020
+#define WIDE_LINKS_MASK       0x0040
 
 #define SETFLAG(mask)	runtime_flags |= mask
 #define GETFLAG(mask)	(runtime_flags & mask)
@@ -212,10 +209,6 @@ extern char serialnumber[];
 #define PRESENTATIONURL_MAX_LEN 64
 extern char presentationurl[];
 
-#if PNPX
-extern char pnpx_hwid[];
-#endif
-
 /* lan addresses */
 extern int n_lan_addr;
 extern struct lan_addr_s lan_addr[];
--- a/upnphttp.c
+++ b/upnphttp.c
@@ -477,6 +477,21 @@ Send400(struct upnphttp * h)
 	CloseSocket_upnphttp(h);
 }
 
+/* very minimalistic 403 error message */
+static void
+Send403(struct upnphttp * h)
+{
+	static const char body403[] =
+		"<HTML><HEAD><TITLE>403 Forbidden</TITLE></HEAD>"
+		"<BODY><H1>Forbidden</H1>You don't have permission to access this resource."
+		"</BODY></HTML>\r\n";
+	h->respflags = FLAG_HTML;
+	BuildResp2_upnphttp(h, 403, "Forbidden",
+	                    body403, sizeof(body403) - 1);
+	SendResp_upnphttp(h);
+	CloseSocket_upnphttp(h);
+}
+
 /* very minimalistic 404 error message */
 static void
 Send404(struct upnphttp * h)
@@ -1328,6 +1343,46 @@ start_dlna_header(struct string_s *str,
 	             respcode, date, tmode, mime);
 }
 
+static int
+_open_file(const char *orig_path)
+{
+	struct media_dir_s *media_path;
+	char buf[PATH_MAX];
+	const char *path;
+	int fd;
+
+	if (!GETFLAG(WIDE_LINKS_MASK))
+	{
+		path = realpath(orig_path, buf);
+		if (!path)
+		{
+			DPRINTF(E_ERROR, L_HTTP, "Error resolving path %s: %s\n",
+						orig_path, strerror(errno));
+			return -1;
+		}
+
+		for (media_path = media_dirs; media_path; media_path = media_path->next)
+		{
+			if (strncmp(path, media_path->path, strlen(media_path->path)) == 0)
+				break;
+		}
+               if (!media_path && strncmp(path, db_path, strlen(db_path)))
+		{
+			DPRINTF(E_ERROR, L_HTTP, "Rejecting wide link %s -> %s\n",
+						orig_path, path);
+			return -403;
+		}
+	}
+	else
+		path = orig_path;
+
+	fd = open(path, O_RDONLY);
+	if (fd < 0)
+		DPRINTF(E_ERROR, L_HTTP, "Error opening %s\n", path);
+
+	return fd;
+}
+
 static void
 SendResp_icon(struct upnphttp * h, char * icon)
 {
@@ -1413,11 +1468,13 @@ SendResp_albumArt(struct upnphttp * h, c
 	}
 	DPRINTF(E_INFO, L_HTTP, "Serving album art ID: %lld [%s]\n", id, path);
 
-	fd = open(path, O_RDONLY);
+	fd = _open_file(path);
 	if( fd < 0 ) {
-		DPRINTF(E_ERROR, L_HTTP, "Error opening %s\n", path);
 		sqlite3_free(path);
-		Send404(h);
+		if (fd == -403)
+			Send403(h);
+		else
+			Send404(h);
 		return;
 	}
 	sqlite3_free(path);
@@ -1461,11 +1518,13 @@ SendResp_caption(struct upnphttp * h, ch
 	}
 	DPRINTF(E_INFO, L_HTTP, "Serving caption ID: %lld [%s]\n", id, path);
 
-	fd = open(path, O_RDONLY);
+	fd = _open_file(path);
 	if( fd < 0 ) {
-		DPRINTF(E_ERROR, L_HTTP, "Error opening %s\n", path);
 		sqlite3_free(path);
-		Send404(h);
+		if (fd == -403)
+			Send403(h);
+		else
+			Send404(h);
 		return;
 	}
 	sqlite3_free(path);
@@ -1914,10 +1973,12 @@ SendResp_dlnafile(struct upnphttp *h, ch
 	}
 
 	offset = h->req_RangeStart;
-	sendfh = open(last_file.path, O_RDONLY);
+	sendfh = _open_file(last_file.path);
 	if( sendfh < 0 ) {
-		DPRINTF(E_ERROR, L_HTTP, "Error opening %s\n", last_file.path);
-		Send404(h);
+		if (sendfh == -403)
+			Send403(h);
+		else
+			Send404(h);
 		goto error;
 	}
 	size = lseek(sendfh, 0, SEEK_END);
--- a/upnpsoap.c
+++ b/upnpsoap.c
@@ -1055,6 +1055,7 @@ callback(void *args, int argc, char **ar
 					break;
 				case ESamsungSeriesCDE:
 				case ELGDevice:
+				case ELGNetCastDevice:
 				case EAsusOPlay:
 				default:
 					if( passed_args->flags & FLAG_HAS_CAPTIONS )
@@ -1064,7 +1065,7 @@ callback(void *args, int argc, char **ar
 									     "http://%s:%d/Captions/%s.srt"
 									   "&lt;/res&gt;",
 									   lan_addr[passed_args->iface].str, runtime_vars.port, detailID);
-						else if( passed_args->filter & FILTER_SEC_CAPTION_INFO_EX )
+						if( passed_args->filter & FILTER_SEC_CAPTION_INFO_EX )
 							ret = strcatf(str, "&lt;sec:CaptionInfoEx sec:type=\"srt\"&gt;"
 							                     "http://%s:%d/Captions/%s.srt"
 							                   "&lt;/sec:CaptionInfoEx&gt;",
@@ -1924,14 +1925,21 @@ SamsungSetBookmark(struct upnphttp * h,
 	ParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data, 0);
 	ObjectID = GetValueFromNameValueList(&data, "ObjectID");
 	PosSecond = GetValueFromNameValueList(&data, "PosSecond");
+
+	if ( atoi(PosSecond) < 30 )
+		PosSecond = "0";
+
 	if( ObjectID && PosSecond )
 	{
 		int ret;
+		const char *rid = ObjectID;
+
+		in_magic_container(ObjectID, 0, &rid);
 		ret = sql_exec(db, "INSERT OR REPLACE into BOOKMARKS"
 		                   " VALUES "
-		                   "((select DETAIL_ID from OBJECTS where OBJECT_ID = '%q'), %q)", ObjectID, PosSecond);
+		                   "((select DETAIL_ID from OBJECTS where OBJECT_ID = '%q'), %q)", rid, PosSecond);
 		if( ret != SQLITE_OK )
-			DPRINTF(E_WARN, L_METADATA, "Error setting bookmark %s on ObjectID='%s'\n", PosSecond, ObjectID);
+			DPRINTF(E_WARN, L_METADATA, "Error setting bookmark %s on ObjectID='%s'\n", PosSecond, rid);
 		BuildSendAndCloseSoapResp(h, resp, sizeof(resp)-1);
 	}
 	else
