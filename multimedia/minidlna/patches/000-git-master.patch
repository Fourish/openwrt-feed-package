--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,14 @@
+1.1.6 - Released 16-June-2016
+--------------------------------
+- Add AllShare and Windows client detection.
+- Update support for LG2012 TV.
+- Fix Samsung bookmarking on magic containers.
+- Fix SQL error when moving captions.
+- Add wide_links config option.
+- Fix external subtitles on Samsung Series J.
+- Add string localization support for magic containers.
+- Rework NLS init to work with non-en_US locales.
+
 1.1.5 - Released 10-Sep-2015
 --------------------------------
 - Re-enable Samsung DCM10, which adds video bookmarks and "BasicView" support.
--- a/clients.c
+++ b/clients.c
@@ -53,6 +53,16 @@ struct client_type_s client_types[] =
 	  EXAVClientInfo
 	},
 
+	/* User-Agent: DLNADOC/1.50 SEC_HHP_[PC]LPC001/1.0  MS-DeviceCaps/1024 */
+	/* This is AllShare running on a PC.  We don't want to respond with Samsung
+	 * capabilities, or Windows (and AllShare) might get grumpy. */
+	{ 0,
+	  FLAG_DLNA,
+	  "AllShare",
+	  "SEC_HHP_[PC]",
+	  EUserAgent
+	},
+
 	/* Samsung Series [CDE] BDPs and TVs must be separated, or some of our
 	 * advertised extra features trigger a folder browsing bug on BDPs. */
 	/* User-Agent: DLNADOC/1.50 SEC_HHP_BD-D5100/1.0 */
@@ -65,9 +75,10 @@ struct client_type_s client_types[] =
 
 	/* User-Agent: DLNADOC/1.50 SEC_HHP_[TV]UE40D7000/1.0 */
 	/* User-Agent: DLNADOC/1.50 SEC_HHP_ Family TV/1.0 */
+	/* USER-AGENT: DLNADOC/1.50 SEC_HHP_[TV] UE65JU7000/1.0 UPnP/1.0 */
 	{ ESamsungSeriesCDE,
-	  FLAG_SAMSUNG | FLAG_DLNA | FLAG_NO_RESIZE | FLAG_SAMSUNG_DCM10,
-	  "Samsung Series [CDEF]",
+	  FLAG_SAMSUNG | FLAG_DLNA | FLAG_NO_RESIZE | FLAG_SAMSUNG_DCM10 | FLAG_CAPTION_RES,
+	  "Samsung Series [CDEFJ]",
 	  "SEC_HHP_",
 	  EUserAgent
 	},
@@ -134,6 +145,14 @@ struct client_type_s client_types[] =
 	  EXAVClientInfo
 	},
 
+	/* USER-AGENT: Linux/2.6.35 UPnP/1.0 DLNADOC/1.50 INTEL_NMPR/2.0 LGE_DLNA_SDK/1.6.0 */
+	{ ELGNetCastDevice,
+	  FLAG_DLNA | FLAG_CAPTION_RES,
+	  "LG",
+	  "LGE_DLNA_SDK/1.6.0",
+	  EUserAgent
+	},
+
 	/* User-Agent: Linux/2.6.31-1.0 UPnP/1.0 DLNADOC/1.50 INTEL_NMPR/2.0 LGE_DLNA_SDK/1.5.0 */
 	{ ELGDevice,
 	  FLAG_DLNA | FLAG_CAPTION_RES,
@@ -221,6 +240,13 @@ struct client_type_s client_types[] =
 	  EUserAgent
 	},
 
+	{ 0,
+	  FLAG_DLNA | FLAG_MIME_AVI_AVI,
+	  "Windows",
+	  "FDSSDP",
+	  EUserAgent
+	},
+
 	{ EStandardDLNA150,
 	  FLAG_DLNA | FLAG_MIME_AVI_AVI,
 	  "Generic DLNA 1.5",
--- a/clients.h
+++ b/clients.h
@@ -57,6 +57,7 @@ enum client_types {
 	EDirecTV,
 	EFreeBox,
 	ELGDevice,
+	ELGNetCastDevice,
 	ELifeTab,
 	EMarantzDMP,
 	EMediaRoom,
--- a/configure.ac
+++ b/configure.ac
@@ -575,7 +575,6 @@ AC_ARG_ENABLE(readynas,
 		AC_DEFINE([NETGEAR],[1],[Define to 1 if you want to enable generic NETGEAR device support])
 		AC_DEFINE([READYNAS],[1],[Define to 1 if you want to enable NETGEAR ReadyNAS support])
 		AC_DEFINE([TIVO_SUPPORT], 1, [Define to 1 if you want to enable TiVo support])
-		AC_DEFINE([PNPX],[5],[Define to 5 if you want to enable NETGEAR ReadyNAS PnP-X support])
 		AC_DEFINE_UNQUOTED([OS_URL],"http://www.readynas.com/")
 		AC_DEFINE_UNQUOTED([ROOTDEV_MANUFACTURERURL],"http://www.netgear.com/")
 		AC_DEFINE_UNQUOTED([ROOTDEV_MANUFACTURER],"NETGEAR")
--- a/inotify.c
+++ b/inotify.c
@@ -25,6 +25,7 @@
 #include <unistd.h>
 #include <dirent.h>
 #include <libgen.h>
+#include <signal.h>
 #include <errno.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -349,9 +350,8 @@ inotify_insert_file(char * name, const c
 			if( !is_image(path) )
 				return -1;
 			break;
-                default:
+		default:
 			return -1;
-			break;
 	}
 	
 	/* If it's already in the database and hasn't been modified, skip it. */
@@ -641,7 +641,7 @@ inotify_remove_directory(int fd, const c
 }
 
 void *
-start_inotify()
+start_inotify(void)
 {
 	struct pollfd pollfds[1];
 	int timeout = 1000;
@@ -650,6 +650,10 @@ start_inotify()
 	int length, i = 0;
 	char * esc_name = NULL;
 	struct stat st;
+	sigset_t set;
+
+	sigfillset(&set);
+	pthread_sigmask(SIG_BLOCK, &set, NULL);
         
 	pollfds[0].fd = inotify_init();
 	pollfds[0].events = POLLIN;
--- a/libav.h
+++ b/libav.h
@@ -155,12 +155,54 @@ lav_get_fps(AVStream *s)
 }
 
 static inline int
-lav_get_interlaced(AVCodecContext *vc, AVStream *s)
+lav_get_interlaced(AVStream *s)
 {
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	return (vc->time_base.den ? (s->r_frame_rate.num / vc->time_base.den) : 0);
+#if LIBAVCODEC_VERSION_MAJOR >= 57
+	return (s->time_base.den ? (s->avg_frame_rate.num / s->time_base.den) : 0);
+#elif LIBAVCODEC_VERSION_MAJOR >= 54
+	return (s->codec->time_base.den ? (s->avg_frame_rate.num / s->codec->time_base.den) : 0);
 #else
-	return (vc->time_base.den ? (s->avg_frame_rate.num / vc->time_base.den) : 0);
+	return (s->codec->time_base.den ? (s->r_frame_rate.num / s->codec->time_base.den) : 0);
+#endif
+}
+
+#if LIBAVCODEC_VERSION_MAJOR >= 57
+#define lav_codec_id(s) s->codecpar->codec_id
+#define lav_codec_type(s) s->codecpar->codec_type
+#define lav_codec_tag(s) s->codecpar->codec_tag
+#define lav_sample_rate(s) s->codecpar->sample_rate
+#define lav_bit_rate(s) s->codecpar->bit_rate
+#define lav_channels(s) s->codecpar->channels
+#define lav_width(s) s->codecpar->width
+#define lav_height(s) s->codecpar->height
+#define lav_profile(s) s->codecpar->profile
+#define lav_level(s) s->codecpar->level
+#define lav_sample_aspect_ratio(s) s->codecpar->sample_aspect_ratio
+#else
+#define lav_codec_id(x) x->codec->codec_id
+#define lav_codec_type(s) s->codec->codec_type
+#define lav_codec_tag(s) s->codec->codec_tag
+#define lav_sample_rate(s) s->codec->sample_rate
+#define lav_bit_rate(s) s->codec->bit_rate
+#define lav_channels(s) s->codec->channels
+#define lav_width(s) s->codec->width
+#define lav_height(s) s->codec->height
+#define lav_profile(s) s->codec->profile
+#define lav_level(s) s->codec->level
+#define lav_sample_aspect_ratio(s) s->codec->sample_aspect_ratio
+#endif
+
+static inline uint8_t *
+lav_codec_extradata(AVStream *s)
+{
+#if LIBAVCODEC_VERSION_MAJOR >= 57
+	if (!s->codecpar->extradata_size)
+		return NULL;
+	return s->codecpar->extradata;
+#else
+	if (!s->codec->extradata_size)
+		return NULL;
+	return s->codec->extradata;
 #endif
 }
 
@@ -169,7 +211,7 @@ lav_is_thumbnail_stream(AVStream *s, uin
 {
 #if LIBAVFORMAT_VERSION_INT >= ((54<<16)+(6<<8))
 	if (s->disposition & AV_DISPOSITION_ATTACHED_PIC &&
-	    s->codec->codec_id == AV_CODEC_ID_MJPEG)
+	    lav_codec_id(s) == AV_CODEC_ID_MJPEG)
 	{
 		if (data)
 			*data = s->attached_pic.data;
--- a/metadata.c
+++ b/metadata.c
@@ -149,7 +149,7 @@ check_for_captions(const char *path, int
 
 	if (ret == 0)
 	{
-		sql_exec(db, "INSERT into CAPTIONS"
+		sql_exec(db, "INSERT OR REPLACE into CAPTIONS"
 		             " (ID, PATH) "
 		             "VALUES"
 		             " (%lld, %Q)", detailID, file);
@@ -663,7 +663,7 @@ GetVideoMetadata(const char *path, char
 	int ret, i;
 	struct tm *modtime;
 	AVFormatContext *ctx = NULL;
-	AVCodecContext *ac = NULL, *vc = NULL;
+	AVStream *astream = NULL, *vstream = NULL;
 	int audio_stream = -1, video_stream = -1;
 	enum audio_profiles audio_profile = PROFILE_AUDIO_UNKNOWN;
 	char fourcc[4];
@@ -692,27 +692,27 @@ GetVideoMetadata(const char *path, char
 		return 0;
 	}
 	//dump_format(ctx, 0, NULL, 0);
-	for( i=0; i<ctx->nb_streams; i++)
+	for( i=0; i < ctx->nb_streams; i++)
 	{
-		if( ctx->streams[i]->codec->codec_type == AVMEDIA_TYPE_AUDIO &&
+		if( lav_codec_type(ctx->streams[i]) == AVMEDIA_TYPE_AUDIO &&
 		    audio_stream == -1 )
 		{
 			audio_stream = i;
-			ac = ctx->streams[audio_stream]->codec;
+			astream = ctx->streams[audio_stream];
 			continue;
 		}
-		else if( ctx->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO &&
+		else if( lav_codec_type(ctx->streams[i]) == AVMEDIA_TYPE_VIDEO &&
 		         !lav_is_thumbnail_stream(ctx->streams[i], &m.thumb_data, &m.thumb_size) &&
 		         video_stream == -1 )
 		{
 			video_stream = i;
-			vc = ctx->streams[video_stream]->codec;
+			vstream = ctx->streams[video_stream];
 			continue;
 		}
 	}
 	path_cpy = strdup(path);
 	basepath = basename(path_cpy);
-	if( !vc )
+	if( !vstream )
 	{
 		/* This must not be a video file. */
 		lav_close(ctx);
@@ -722,24 +722,23 @@ GetVideoMetadata(const char *path, char
 		return 0;
 	}
 
-	if( ac )
+	if( astream )
 	{
 		aac_object_type_t aac_type = AAC_INVALID;
-		switch( ac->codec_id )
+		switch( lav_codec_id(astream) )
 		{
 			case AV_CODEC_ID_MP3:
 				audio_profile = PROFILE_AUDIO_MP3;
 				break;
 			case AV_CODEC_ID_AAC:
-				if( !ac->extradata_size ||
-				    !ac->extradata )
+				if( !lav_codec_extradata(astream) )
 				{
 					DPRINTF(E_DEBUG, L_METADATA, "No AAC type\n");
 				}
 				else
 				{
 					uint8_t data;
-					memcpy(&data, ac->extradata, 1);
+					memcpy(&data, lav_codec_extradata(astream), 1);
 					aac_type = data >> 3;
 				}
 				switch( aac_type )
@@ -747,24 +746,24 @@ GetVideoMetadata(const char *path, char
 					/* AAC Low Complexity variants */
 					case AAC_LC:
 					case AAC_LC_ER:
-						if( ac->sample_rate < 8000 ||
-						    ac->sample_rate > 48000 )
+						if( lav_sample_rate(astream) < 8000 ||
+						    lav_sample_rate(astream) > 48000 )
 						{
 							DPRINTF(E_DEBUG, L_METADATA, "Unsupported AAC: sample rate is not 8000 < %d < 48000\n",
-								ac->sample_rate);
+								lav_sample_rate(astream));
 							break;
 						}
 						/* AAC @ Level 1/2 */
-						if( ac->channels <= 2 &&
-						    ac->bit_rate <= 576000 )
+						if( lav_channels(astream) <= 2 &&
+						    lav_bit_rate(astream) <= 576000 )
 							audio_profile = PROFILE_AUDIO_AAC;
-						else if( ac->channels <= 6 &&
-							 ac->bit_rate <= 1440000 )
+						else if( lav_channels(astream) <= 6 &&
+							 lav_bit_rate(astream) <= 1440000 )
 							audio_profile = PROFILE_AUDIO_AAC_MULT5;
 						else
-							DPRINTF(E_DEBUG, L_METADATA, "Unhandled AAC: %d channels, %d bitrate\n",
-								ac->channels,
-								ac->bit_rate);
+							DPRINTF(E_DEBUG, L_METADATA, "Unhandled AAC: %lld channels, %lld bitrate\n",
+								(long long)lav_channels(astream),
+								(long long)lav_bit_rate(astream));
 						break;
 					default:
 						DPRINTF(E_DEBUG, L_METADATA, "Unhandled AAC type [%d]\n", aac_type);
@@ -778,10 +777,10 @@ GetVideoMetadata(const char *path, char
 			case AV_CODEC_ID_WMAV1:
 			case AV_CODEC_ID_WMAV2:
 				/* WMA Baseline: stereo, up to 48 KHz, up to 192,999 bps */
-				if ( ac->bit_rate <= 193000 )
+				if ( lav_bit_rate(astream) <= 193000 )
 					audio_profile = PROFILE_AUDIO_WMA_BASE;
 				/* WMA Full: stereo, up to 48 KHz, up to 385 Kbps */
-				else if ( ac->bit_rate <= 385000 )
+				else if ( lav_bit_rate(astream) <= 385000 )
 					audio_profile = PROFILE_AUDIO_WMA_FULL;
 				break;
 			case AV_CODEC_ID_WMAPRO:
@@ -794,23 +793,23 @@ GetVideoMetadata(const char *path, char
 				audio_profile = PROFILE_AUDIO_AMR;
 				break;
 			default:
-				if( (ac->codec_id >= AV_CODEC_ID_PCM_S16LE) &&
-				    (ac->codec_id < AV_CODEC_ID_ADPCM_IMA_QT) )
+				if( (lav_codec_id(astream) >= AV_CODEC_ID_PCM_S16LE) &&
+				    (lav_codec_id(astream) < AV_CODEC_ID_ADPCM_IMA_QT) )
 					audio_profile = PROFILE_AUDIO_PCM;
 				else
-					DPRINTF(E_DEBUG, L_METADATA, "Unhandled audio codec [0x%X]\n", ac->codec_id);
+					DPRINTF(E_DEBUG, L_METADATA, "Unhandled audio codec [0x%X]\n", lav_codec_id(astream));
 				break;
 		}
-		m.frequency = ac->sample_rate;
-		m.channels = ac->channels;
+		m.frequency = lav_sample_rate(astream);
+		m.channels = lav_channels(astream);
 	}
-	if( vc )
+	if( vstream )
 	{
 		int off;
 		int duration, hours, min, sec, ms;
 		ts_timestamp_t ts_timestamp = NONE;
 		DPRINTF(E_DEBUG, L_METADATA, "Container: '%s' [%s]\n", ctx->iformat->name, basepath);
-		xasprintf(&m.resolution, "%dx%d", vc->width, vc->height);
+		xasprintf(&m.resolution, "%dx%d", lav_width(vstream), lav_height(vstream));
 		if( ctx->bit_rate > 8 )
 			m.bitrate = ctx->bit_rate / 8;
 		if( ctx->duration > 0 ) {
@@ -827,12 +826,12 @@ GetVideoMetadata(const char *path, char
 		if( strcmp(ctx->iformat->name, "avi") == 0 )
 		{
 			xasprintf(&m.mime, "video/x-msvideo");
-			if( vc->codec_id == AV_CODEC_ID_MPEG4 )
+			if( lav_codec_id(vstream) == AV_CODEC_ID_MPEG4 )
 			{
-        			fourcc[0] = vc->codec_tag     & 0xff;
-			        fourcc[1] = vc->codec_tag>>8  & 0xff;
-		        	fourcc[2] = vc->codec_tag>>16 & 0xff;
-			        fourcc[3] = vc->codec_tag>>24 & 0xff;
+				fourcc[0] = lav_codec_tag(vstream)     & 0xff;
+				fourcc[1] = lav_codec_tag(vstream)>>8  & 0xff;
+				fourcc[2] = lav_codec_tag(vstream)>>16 & 0xff;
+				fourcc[3] = lav_codec_tag(vstream)>>24 & 0xff;
 				if( memcmp(fourcc, "XVID", 4) == 0 ||
 				    memcmp(fourcc, "DX50", 4) == 0 ||
 				    memcmp(fourcc, "DIVX", 4) == 0 )
@@ -849,13 +848,13 @@ GetVideoMetadata(const char *path, char
 		if( m.mime )
 			goto video_no_dlna;
 
-		switch( vc->codec_id )
+		switch( lav_codec_id(vstream) )
 		{
 			case AV_CODEC_ID_MPEG1VIDEO:
 				if( strcmp(ctx->iformat->name, "mpeg") == 0 )
 				{
-					if( (vc->width  == 352) &&
-					    (vc->height <= 288) )
+					if( (lav_width(vstream)  == 352) &&
+					    (lav_height(vstream) <= 288) )
 					{
 						m.dlna_pn = strdup("MPEG1");
 					}
@@ -872,16 +871,16 @@ GetVideoMetadata(const char *path, char
 					DPRINTF(E_DEBUG, L_METADATA, "Stream %d of %s is %s MPEG2 TS packet size %d\n",
 						video_stream, basepath, m.resolution, raw_packet_size);
 					off += sprintf(m.dlna_pn+off, "TS_");
-					if( (vc->width  >= 1280) &&
-					    (vc->height >= 720) )
+					if( (lav_width(vstream)  >= 1280) &&
+					    (lav_height(vstream) >= 720) )
 					{
 						off += sprintf(m.dlna_pn+off, "HD_NA");
 					}
 					else
 					{
 						off += sprintf(m.dlna_pn+off, "SD_");
-						if( (vc->height == 576) ||
-						    (vc->height == 288) )
+						if( (lav_height(vstream) == 576) ||
+						    (lav_height(vstream) == 288) )
 							off += sprintf(m.dlna_pn+off, "EU");
 						else
 							off += sprintf(m.dlna_pn+off, "NA");
@@ -920,8 +919,8 @@ GetVideoMetadata(const char *path, char
 					DPRINTF(E_DEBUG, L_METADATA, "Stream %d of %s is %s MPEG2 PS\n",
 						video_stream, basepath, m.resolution);
 					off += sprintf(m.dlna_pn+off, "PS_");
-					if( (vc->height == 576) ||
-					    (vc->height == 288) )
+					if( (lav_height(vstream) == 576) ||
+					    (lav_height(vstream) == 288) )
 						off += sprintf(m.dlna_pn+off, "PAL");
 					else
 						off += sprintf(m.dlna_pn+off, "NTSC");
@@ -947,53 +946,53 @@ GetVideoMetadata(const char *path, char
 					int dlna_ts_present = dlna_timestamp_is_present(path, &raw_packet_size);
 
 					off += sprintf(m.dlna_pn+off, "TS_");
-					if (vc->sample_aspect_ratio.num) {
+					if (lav_sample_aspect_ratio(vstream).num) {
 						av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,
-						          vc->width  * vc->sample_aspect_ratio.num,
-						          vc->height * vc->sample_aspect_ratio.den,
+						          lav_width(vstream) * lav_sample_aspect_ratio(vstream).num,
+						          lav_height(vstream) * lav_sample_aspect_ratio(vstream).den,
 						          1024*1024);
 					}
-					fps = lav_get_fps(ctx->streams[video_stream]);
-					interlaced = lav_get_interlaced(vc, ctx->streams[video_stream]);
-					if( ((((vc->width == 1920 || vc->width == 1440) && vc->height == 1080) ||
-					      (vc->width == 720 && vc->height == 480)) && fps == 59 && interlaced) ||
-					    ((vc->width == 1280 && vc->height == 720) && fps == 59 && !interlaced) )
+					fps = lav_get_fps(vstream);
+					interlaced = lav_get_interlaced(vstream);
+					if( ((((lav_width(vstream) == 1920 || lav_width(vstream) == 1440) && lav_height(vstream) == 1080) ||
+					      (lav_width(vstream) == 720 && lav_height(vstream) == 480)) && fps == 59 && interlaced) ||
+					    ((lav_width(vstream) == 1280 && lav_height(vstream) == 720) && fps == 59 && !interlaced) )
 					{
-						if( (vc->profile == FF_PROFILE_H264_MAIN || vc->profile == FF_PROFILE_H264_HIGH) &&
+						if( (lav_profile(vstream) == FF_PROFILE_H264_MAIN || lav_profile(vstream) == FF_PROFILE_H264_HIGH) &&
 						    audio_profile == PROFILE_AUDIO_AC3 )
 						{
 							off += sprintf(m.dlna_pn+off, "HD_60_");
-							vc->profile = FF_PROFILE_SKIP;
+							lav_profile(vstream) = FF_PROFILE_SKIP;
 						}
 					}
-					else if( ((vc->width == 1920 && vc->height == 1080) ||
-					          (vc->width == 1440 && vc->height == 1080) ||
-					          (vc->width == 1280 && vc->height ==  720) ||
-					          (vc->width ==  720 && vc->height ==  576)) &&
+					else if( ((lav_width(vstream) == 1920 && lav_height(vstream) == 1080) ||
+					          (lav_width(vstream) == 1440 && lav_height(vstream) == 1080) ||
+					          (lav_width(vstream) == 1280 && lav_height(vstream) ==  720) ||
+					          (lav_width(vstream) ==  720 && lav_height(vstream) ==  576)) &&
 					          interlaced && fps == 50 )
 					{
-						if( (vc->profile == FF_PROFILE_H264_MAIN || vc->profile == FF_PROFILE_H264_HIGH) &&
+						if( (lav_profile(vstream) == FF_PROFILE_H264_MAIN || lav_profile(vstream) == FF_PROFILE_H264_HIGH) &&
 						    audio_profile == PROFILE_AUDIO_AC3 )
 						{
 							off += sprintf(m.dlna_pn+off, "HD_50_");
-							vc->profile = FF_PROFILE_SKIP;
+							lav_profile(vstream) = FF_PROFILE_SKIP;
 						}
 					}
-					switch( vc->profile )
+					switch( lav_profile(vstream) )
 					{
 						case FF_PROFILE_H264_BASELINE:
 						case FF_PROFILE_H264_CONSTRAINED_BASELINE:
 							off += sprintf(m.dlna_pn+off, "BL_");
-							if( vc->width  <= 352 &&
-							    vc->height <= 288 &&
-							    vc->bit_rate <= 384000 )
+							if( lav_width(vstream)  <= 352 &&
+							    lav_height(vstream) <= 288 &&
+							    lav_bit_rate(vstream) <= 384000 )
 							{
 								off += sprintf(m.dlna_pn+off, "CIF15_");
 								break;
 							}
-							else if( vc->width  <= 352 &&
-							         vc->height <= 288 &&
-							         vc->bit_rate <= 3000000 )
+							else if( lav_width(vstream)  <= 352 &&
+							         lav_height(vstream) <= 288 &&
+							         lav_bit_rate(vstream) <= 3000000 )
 							{
 								off += sprintf(m.dlna_pn+off, "CIF30_");
 								break;
@@ -1004,46 +1003,47 @@ GetVideoMetadata(const char *path, char
 						default:
 						case FF_PROFILE_H264_MAIN:
 							off += sprintf(m.dlna_pn+off, "MP_");
-							if( vc->profile != FF_PROFILE_H264_BASELINE &&
-							    vc->profile != FF_PROFILE_H264_CONSTRAINED_BASELINE &&
-							    vc->profile != FF_PROFILE_H264_MAIN )
+							if( lav_profile(vstream) != FF_PROFILE_H264_BASELINE &&
+							    lav_profile(vstream) != FF_PROFILE_H264_CONSTRAINED_BASELINE &&
+							    lav_profile(vstream) != FF_PROFILE_H264_MAIN )
 							{
 								DPRINTF(E_DEBUG, L_METADATA, "Unknown AVC profile %d; assuming MP. [%s]\n",
-									vc->profile, basepath);
+									lav_profile(vstream), basepath);
 							}
-							if( vc->width  <= 720 &&
-							    vc->height <= 576 &&
-							    vc->bit_rate <= 10000000 )
+							if( lav_width(vstream)  <= 720 &&
+							    lav_height(vstream) <= 576 &&
+							    lav_bit_rate(vstream) <= 10000000 )
 							{
 								off += sprintf(m.dlna_pn+off, "SD_");
 							}
-							else if( vc->width  <= 1920 &&
-							         vc->height <= 1152 &&
-							         vc->bit_rate <= 20000000 )
+							else if( lav_width(vstream)  <= 1920 &&
+							         lav_height(vstream) <= 1152 &&
+							         lav_bit_rate(vstream) <= 20000000 )
 							{
 								off += sprintf(m.dlna_pn+off, "HD_");
 							}
 							else
 							{
-								DPRINTF(E_DEBUG, L_METADATA, "Unsupported h.264 video profile! [%s, %dx%d, %dbps : %s]\n",
-									m.dlna_pn, vc->width, vc->height, vc->bit_rate, basepath);
+								DPRINTF(E_DEBUG, L_METADATA, "Unsupported h.264 video profile! [%s, %dx%d, %lldbps : %s]\n",
+									m.dlna_pn, lav_width(vstream), lav_height(vstream),
+									(long long)lav_bit_rate(vstream), basepath);
 								free(m.dlna_pn);
 								m.dlna_pn = NULL;
 							}
 							break;
 						case FF_PROFILE_H264_HIGH:
 							off += sprintf(m.dlna_pn+off, "HP_");
-							if( vc->width  <= 1920 &&
-							    vc->height <= 1152 &&
-							    vc->bit_rate <= 30000000 &&
+							if( lav_width(vstream)  <= 1920 &&
+							    lav_height(vstream) <= 1152 &&
+							    lav_bit_rate(vstream) <= 30000000 &&
 							    audio_profile == PROFILE_AUDIO_AC3 )
 							{
 								off += sprintf(m.dlna_pn+off, "HD_");
 							}
 							else
 							{
-								DPRINTF(E_DEBUG, L_METADATA, "Unsupported h.264 HP video profile! [%dbps, %d audio : %s]\n",
-									vc->bit_rate, audio_profile, basepath);
+								DPRINTF(E_DEBUG, L_METADATA, "Unsupported h.264 HP video profile! [%lldbps, %d audio : %s]\n",
+									(long long)lav_bit_rate(vstream), audio_profile, basepath);
 								free(m.dlna_pn);
 								m.dlna_pn = NULL;
 							}
@@ -1076,7 +1076,7 @@ GetVideoMetadata(const char *path, char
 						break;
 					if( raw_packet_size == MPEG_TS_PACKET_LENGTH_DLNA )
 					{
-						if( vc->profile == FF_PROFILE_H264_HIGH ||
+						if( lav_profile(vstream) == FF_PROFILE_H264_HIGH ||
 						    dlna_ts_present )
 							ts_timestamp = VALID;
 						else
@@ -1107,11 +1107,11 @@ GetVideoMetadata(const char *path, char
 				{
 					off += sprintf(m.dlna_pn+off, "MP4_");
 
-					switch( vc->profile ) {
+					switch( lav_profile(vstream) ) {
 					case FF_PROFILE_H264_BASELINE:
 					case FF_PROFILE_H264_CONSTRAINED_BASELINE:
-						if( vc->width  <= 352 &&
-						    vc->height <= 288 )
+						if( lav_width(vstream)  <= 352 &&
+						    lav_height(vstream) <= 288 )
 						{
 							if( ctx->bit_rate < 600000 )
 								off += sprintf(m.dlna_pn+off, "BL_CIF15_");
@@ -1147,28 +1147,28 @@ GetVideoMetadata(const char *path, char
 								goto mp4_mp_fallback;
 							}
 						}
-						else if( vc->width  <= 720 &&
-						         vc->height <= 576 )
+						else if( lav_width(vstream)  <= 720 &&
+						         lav_height(vstream) <= 576 )
 						{
-							if( vc->level == 30 &&
+							if( lav_level(vstream) == 30 &&
 							    audio_profile == PROFILE_AUDIO_AAC &&
 							    ctx->bit_rate <= 5000000 )
 								off += sprintf(m.dlna_pn+off, "BL_L3L_SD_AAC");
-							else if( vc->level <= 31 &&
+							else if( lav_level(vstream) <= 31 &&
 							         audio_profile == PROFILE_AUDIO_AAC &&
 							         ctx->bit_rate <= 15000000 )
 								off += sprintf(m.dlna_pn+off, "BL_L31_HD_AAC");
 							else
 								goto mp4_mp_fallback;
 						}
-						else if( vc->width  <= 1280 &&
-						         vc->height <= 720 )
+						else if( lav_width(vstream)  <= 1280 &&
+						         lav_height(vstream) <= 720 )
 						{
-							if( vc->level <= 31 &&
+							if( lav_level(vstream) <= 31 &&
 							    audio_profile == PROFILE_AUDIO_AAC &&
 							    ctx->bit_rate <= 15000000 )
 								off += sprintf(m.dlna_pn+off, "BL_L31_HD_AAC");
-							else if( vc->level <= 32 &&
+							else if( lav_level(vstream) <= 32 &&
 							         audio_profile == PROFILE_AUDIO_AAC &&
 							         ctx->bit_rate <= 21000000 )
 								off += sprintf(m.dlna_pn+off, "BL_L32_HD_AAC");
@@ -1182,9 +1182,9 @@ GetVideoMetadata(const char *path, char
 					mp4_mp_fallback:
 						off += sprintf(m.dlna_pn+off, "MP_");
 						/* AVC MP4 SD profiles - 10 Mbps max */
-						if( vc->width  <= 720 &&
-						    vc->height <= 576 &&
-						    vc->bit_rate <= 10000000 )
+						if( lav_width(vstream)  <= 720 &&
+						    lav_height(vstream) <= 576 &&
+						    lav_bit_rate(vstream) <= 10000000 )
 						{
 							sprintf(m.dlna_pn+off, "SD_");
 							if( audio_profile == PROFILE_AUDIO_AC3 )
@@ -1197,16 +1197,16 @@ GetVideoMetadata(const char *path, char
 							else
 								m.dlna_pn[10] = '\0';
 						}
-						else if( vc->width  <= 1280 &&
-						         vc->height <= 720 &&
-						         vc->bit_rate <= 15000000 &&
+						else if( lav_width(vstream)  <= 1280 &&
+						         lav_height(vstream) <= 720 &&
+						         lav_bit_rate(vstream) <= 15000000 &&
 						         audio_profile == PROFILE_AUDIO_AAC )
 						{
 							off += sprintf(m.dlna_pn+off, "HD_720p_AAC");
 						}
-						else if( vc->width  <= 1920 &&
-						         vc->height <= 1080 &&
-						         vc->bit_rate <= 21000000 &&
+						else if( lav_width(vstream)  <= 1920 &&
+						         lav_height(vstream) <= 1080 &&
+						         lav_bit_rate(vstream) <= 21000000 &&
 						         audio_profile == PROFILE_AUDIO_AAC )
 						{
 							off += sprintf(m.dlna_pn+off, "HD_1080i_AAC");
@@ -1220,9 +1220,9 @@ GetVideoMetadata(const char *path, char
 						}
 						break;
 					case FF_PROFILE_H264_HIGH:
-						if( vc->width  <= 1920 &&
-						    vc->height <= 1080 &&
-						    vc->bit_rate <= 25000000 &&
+						if( lav_width(vstream)  <= 1920 &&
+						    lav_height(vstream) <= 1080 &&
+						    lav_bit_rate(vstream) <= 25000000 &&
 						    audio_profile == PROFILE_AUDIO_AAC )
 						{
 							off += sprintf(m.dlna_pn+off, "HP_HD_AAC");
@@ -1230,7 +1230,7 @@ GetVideoMetadata(const char *path, char
 						break;
 					default:
 						DPRINTF(E_DEBUG, L_METADATA, "AVC profile [%d] not recognized for file %s\n",
-							vc->profile, basepath);
+							lav_profile(vstream), basepath);
 						free(m.dlna_pn);
 						m.dlna_pn = NULL;
 						break;
@@ -1244,17 +1244,17 @@ GetVideoMetadata(const char *path, char
 				DPRINTF(E_DEBUG, L_METADATA, "Stream %d of %s is h.264\n", video_stream, basepath);
 				break;
 			case AV_CODEC_ID_MPEG4:
-        			fourcc[0] = vc->codec_tag     & 0xff;
-			        fourcc[1] = vc->codec_tag>>8  & 0xff;
-			        fourcc[2] = vc->codec_tag>>16 & 0xff;
-			        fourcc[3] = vc->codec_tag>>24 & 0xff;
+				fourcc[0] = lav_codec_tag(vstream)     & 0xff;
+				fourcc[1] = lav_codec_tag(vstream)>>8  & 0xff;
+				fourcc[2] = lav_codec_tag(vstream)>>16 & 0xff;
+				fourcc[3] = lav_codec_tag(vstream)>>24 & 0xff;
 				DPRINTF(E_DEBUG, L_METADATA, "Stream %d of %s is MPEG4 [%c%c%c%c/0x%X]\n",
 					video_stream, basepath,
 					isprint(fourcc[0]) ? fourcc[0] : '_',
 					isprint(fourcc[1]) ? fourcc[1] : '_',
 					isprint(fourcc[2]) ? fourcc[2] : '_',
 					isprint(fourcc[3]) ? fourcc[3] : '_',
-					vc->codec_tag);
+					lav_codec_tag(vstream));
 
 				if( strcmp(ctx->iformat->name, "mov,mp4,m4a,3gp,3g2,mj2") == 0 )
 				{
@@ -1274,7 +1274,7 @@ GetVideoMetadata(const char *path, char
 								break;
 							default:
 								DPRINTF(E_DEBUG, L_METADATA, "No DLNA profile found for MPEG4-P2 3GP/0x%X file %s\n",
-								        ac->codec_id, basepath);
+								        lav_codec_id(astream), basepath);
 								free(m.dlna_pn);
 								m.dlna_pn = NULL;
 								break;
@@ -1288,18 +1288,18 @@ GetVideoMetadata(const char *path, char
 							off += sprintf(m.dlna_pn+off, "MP4_ASP_AAC");
 						}
 						else if( ctx->bit_rate <= 4000000 &&
-						         vc->width  <= 640 &&
-						         vc->height <= 480 &&
+						         lav_width(vstream)  <= 640 &&
+						         lav_height(vstream) <= 480 &&
 						         audio_profile == PROFILE_AUDIO_AAC )
 						{
 							off += sprintf(m.dlna_pn+off, "MP4_SP_VGA_AAC");
 						}
 						else
 						{
-							DPRINTF(E_DEBUG, L_METADATA, "Unsupported h.264 video profile! [%dx%d, %dbps]\n",
-								vc->width,
-								vc->height,
-								ctx->bit_rate);
+							DPRINTF(E_DEBUG, L_METADATA, "Unsupported h.264 video profile! [%dx%d, %lldbps]\n",
+								lav_width(vstream),
+								lav_height(vstream),
+								(long long)ctx->bit_rate);
 							free(m.dlna_pn);
 							m.dlna_pn = NULL;
 						}
@@ -1308,12 +1308,12 @@ GetVideoMetadata(const char *path, char
 				break;
 			case AV_CODEC_ID_WMV3:
 				/* I'm not 100% sure this is correct, but it works on everything I could get my hands on */
-				if( vc->extradata_size > 0 )
+				if( lav_codec_extradata(vstream) )
 				{
-					if( !((vc->extradata[0] >> 3) & 1) )
-						vc->level = 0;
-					if( !((vc->extradata[0] >> 6) & 1) )
-						vc->profile = 0;
+					if( !((lav_codec_extradata(vstream)[0] >> 3) & 1) )
+						lav_level(vstream) = 0;
+					if( !((lav_codec_extradata(vstream)[0] >> 6) & 1) )
+						lav_profile(vstream) = 0;
 				}
 			case AV_CODEC_ID_VC1:
 				if( strcmp(ctx->iformat->name, "asf") != 0 )
@@ -1325,9 +1325,9 @@ GetVideoMetadata(const char *path, char
 				off = sprintf(m.dlna_pn, "WMV");
 				DPRINTF(E_DEBUG, L_METADATA, "Stream %d of %s is VC1\n", video_stream, basepath);
 				xasprintf(&m.mime, "video/x-ms-wmv");
-				if( (vc->width  <= 176) &&
-				    (vc->height <= 144) &&
-				    (vc->level == 0) )
+				if( (lav_width(vstream)  <= 176) &&
+				    (lav_height(vstream) <= 144) &&
+				    (lav_level(vstream) == 0) )
 				{
 					off += sprintf(m.dlna_pn+off, "SPLL_");
 					switch( audio_profile )
@@ -1346,9 +1346,9 @@ GetVideoMetadata(const char *path, char
 							break;
 					}
 				}
-				else if( (vc->width  <= 352) &&
-				         (vc->height <= 288) &&
-				         (vc->profile == 0) &&
+				else if( (lav_width(vstream)  <= 352) &&
+				         (lav_height(vstream) <= 288) &&
+				         (lav_profile(vstream) == 0) &&
 				         (ctx->bit_rate/8 <= 384000) )
 				{
 					off += sprintf(m.dlna_pn+off, "SPML_");
@@ -1368,8 +1368,8 @@ GetVideoMetadata(const char *path, char
 							break;
 					}
 				}
-				else if( (vc->width  <= 720) &&
-				         (vc->height <= 576) &&
+				else if( (lav_width(vstream)  <= 720) &&
+				         (lav_height(vstream) <= 576) &&
 				         (ctx->bit_rate/8 <= 10000000) )
 				{
 					off += sprintf(m.dlna_pn+off, "MED_");
@@ -1392,8 +1392,8 @@ GetVideoMetadata(const char *path, char
 							break;
 					}
 				}
-				else if( (vc->width  <= 1920) &&
-				         (vc->height <= 1080) &&
+				else if( (lav_width(vstream)  <= 1920) &&
+				         (lav_height(vstream) <= 1080) &&
 				         (ctx->bit_rate/8 <= 20000000) )
 				{
 					off += sprintf(m.dlna_pn+off, "HIGH_");
@@ -1418,7 +1418,7 @@ GetVideoMetadata(const char *path, char
 				xasprintf(&m.mime, "video/x-msvideo");
 			default:
 				DPRINTF(E_DEBUG, L_METADATA, "Stream %d of %s is %s [type %d]\n",
-					video_stream, basepath, m.resolution, vc->codec_id);
+					video_stream, basepath, m.resolution, lav_codec_id(vstream));
 				break;
 		}
 	}
--- a/minidlna.c
+++ b/minidlna.c
@@ -238,30 +238,6 @@ getfriendlyname(char *buf, int len)
 		}
 	}
 	fclose(info);
-#if PNPX
-	memcpy(pnpx_hwid+4, "01F2", 4);
-	if (strcmp(modelnumber, "NVX") == 0)
-		memcpy(pnpx_hwid+17, "0101", 4);
-	else if (strcmp(modelnumber, "Pro") == 0 ||
-	         strcmp(modelnumber, "Pro 6") == 0 ||
-	         strncmp(modelnumber, "Ultra 6", 7) == 0)
-		memcpy(pnpx_hwid+17, "0102", 4);
-	else if (strcmp(modelnumber, "Pro 2") == 0 ||
-	         strncmp(modelnumber, "Ultra 2", 7) == 0)
-		memcpy(pnpx_hwid+17, "0103", 4);
-	else if (strcmp(modelnumber, "Pro 4") == 0 ||
-	         strncmp(modelnumber, "Ultra 4", 7) == 0)
-		memcpy(pnpx_hwid+17, "0104", 4);
-	else if (strcmp(modelnumber+1, "100") == 0)
-		memcpy(pnpx_hwid+17, "0105", 4);
-	else if (strcmp(modelnumber+1, "200") == 0)
-		memcpy(pnpx_hwid+17, "0106", 4);
-	/* 0107 = Stora */
-	else if (strcmp(modelnumber, "Duo v2") == 0)
-		memcpy(pnpx_hwid+17, "0108", 4);
-	else if (strcmp(modelnumber, "NV+ v2") == 0)
-		memcpy(pnpx_hwid+17, "0109", 4);
-#endif
 #else
 	char * logname;
 	logname = getenv("LOGNAME");
@@ -468,9 +444,21 @@ static int strtobool(const char *str)
 static void init_nls(void)
 {
 #ifdef ENABLE_NLS
-	setlocale(LC_MESSAGES, "");
-	setlocale(LC_CTYPE, "en_US.utf8");
-	DPRINTF(E_DEBUG, L_GENERAL, "Using locale dir %s\n", bindtextdomain("minidlna", getenv("TEXTDOMAINDIR")));
+	const char *messages, *ctype, *locale_dir;
+
+	ctype = setlocale(LC_CTYPE, "");
+	if (!ctype || !strcmp(ctype, "C"))
+		ctype = setlocale(LC_CTYPE, "en_US.utf8");
+	if (!ctype)
+		DPRINTF(E_WARN, L_GENERAL, "Unset locale\n");
+	else if (!strstr(ctype, "utf8") && !strstr(ctype, "UTF8") &&
+		 !strstr(ctype, "utf-8") && !strstr(ctype, "UTF-8"))
+		DPRINTF(E_WARN, L_GENERAL, "Using unsupported non-utf8 locale '%s'\n", ctype);
+	messages = setlocale(LC_MESSAGES, "");
+	if (!messages)
+		messages = "unset";
+	locale_dir = bindtextdomain("minidlna", getenv("TEXTDOMAINDIR"));
+	DPRINTF(E_DEBUG, L_GENERAL, "Using locale dir '%s' and locale langauge %s/%s\n", locale_dir, messages, ctype);
 	textdomain("minidlna");
 #endif
 }
@@ -738,6 +726,10 @@ init(int argc, char **argv)
 			if (strtobool(ary_options[i].value))
 				SETFLAG(MERGE_MEDIA_DIRS_MASK);
 			break;
+		case WIDE_LINKS:
+			if (strtobool(ary_options[i].value))
+				SETFLAG(WIDE_LINKS_MASK);
+			break;
 		default:
 			DPRINTF(E_ERROR, L_GENERAL, "Unknown option in file %s\n",
 				optionsfile);
@@ -1021,11 +1013,11 @@ main(int argc, char **argv)
 
 	for (i = 0; i < L_MAX; i++)
 		log_level[i] = E_WARN;
-	init_nls();
 
 	ret = init(argc, argv);
 	if (ret != 0)
 		return 1;
+	init_nls();
 
 	DPRINTF(E_WARN, L_GENERAL, "Starting " SERVER_NAME " version " MINIDLNA_VERSION ".\n");
 	if (sqlite3_libversion_number() < 3005001)
@@ -1299,10 +1291,6 @@ shutdown:
 	if (scanning && scanner_pid)
 		kill(scanner_pid, SIGKILL);
 
-	/* kill other child processes */
-	process_reap_children();
-	free(children);
-
 	/* close out open sockets */
 	while (upnphttphead.lh_first != NULL)
 	{
@@ -1330,6 +1318,10 @@ shutdown:
 	if (inotify_thread)
 		pthread_join(inotify_thread, NULL);
 
+	/* kill other child processes */
+	process_reap_children();
+	free(children);
+
 	sql_exec(db, "UPDATE SETTINGS set VALUE = '%u' where KEY = 'UPDATE_ID'", updateID);
 	sqlite3_close(db);
 
--- a/minidlna.conf
+++ b/minidlna.conf
@@ -81,3 +81,6 @@ model_number=1
 # maximum number of simultaneous connections
 # note: many clients open several simultaneous connections while streaming
 #max_connections=50
+
+# set this to yes to allow symlinks that point outside user-defined media_dirs.
+#wide_links=no
--- a/minidlna.conf.5
+++ b/minidlna.conf.5
@@ -163,6 +163,10 @@ force_sort_criteria=+upnp:class,+upnp:or
 
 .fi
 
+.IP "\fBwide_links\fP"
+Set to 'yes' to allow symlinks that point outside user-defined media_dirs.
+By default, wide symlinks are not followed.
+
 
 
 .SH VERSION
--- a/options.c
+++ b/options.c
@@ -64,7 +64,8 @@ static const struct {
 	{ USER_ACCOUNT, "user" },
 	{ FORCE_SORT_CRITERIA, "force_sort_criteria" },
 	{ MAX_CONNECTIONS, "max_connections" },
-	{ MERGE_MEDIA_DIRS, "merge_media_dirs" }
+	{ MERGE_MEDIA_DIRS, "merge_media_dirs" },
+	{ WIDE_LINKS, "wide_links" }
 };
 
 int
--- a/options.h
+++ b/options.h
@@ -57,7 +57,8 @@ enum upnpconfigoptions {
 	USER_ACCOUNT,			/* user account to run as */
 	FORCE_SORT_CRITERIA,		/* force sorting by a given sort criteria */
 	MAX_CONNECTIONS,		/* maximum number of simultaneous connections */
-	MERGE_MEDIA_DIRS		/* don't add an extra directory level when there are multiple media dirs */
+	MERGE_MEDIA_DIRS,		/* don't add an extra directory level when there are multiple media dirs */
+	WIDE_LINKS			/* allow following symlinks outside the defined media_dirs */
 };
 
 /* readoptionsfile()
--- a/po/da.po
+++ b/po/da.po
@@ -68,6 +68,10 @@ msgstr "Mapper"
 msgid "Playlists"
 msgstr "Afspilningslister"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "Nylig tilføjet"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Film"
--- a/po/de.po
+++ b/po/de.po
@@ -83,6 +83,10 @@ msgstr "Ordner"
 msgid "Playlists"
 msgstr "Wiedergabelisten"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "Kürzlich hinzugefügt"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Video"
--- a/po/es.po
+++ b/po/es.po
@@ -68,6 +68,10 @@ msgstr "Carpetas"
 msgid "Playlists"
 msgstr "Listas"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "Recientemente añadido"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Vídeo"
--- a/po/fr.po
+++ b/po/fr.po
@@ -68,6 +68,10 @@ msgstr "Dossiers"
 msgid "Playlists"
 msgstr "Liste de lecture"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "Ajouts récents"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Vidéo"
--- a/po/it.po
+++ b/po/it.po
@@ -70,6 +70,10 @@ msgstr "Cartelle"
 msgid "Playlists"
 msgstr "Scalette"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "Aggiunto recentemente"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Video"
--- a/po/ja.po
+++ b/po/ja.po
@@ -68,6 +68,10 @@ msgstr "フォルダ"
 msgid "Playlists"
 msgstr "プレイリスト"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "最近追加された"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "ビデオ"
--- a/po/ko.po
+++ b/po/ko.po
@@ -68,6 +68,10 @@ msgstr "폴더"
 msgid "Playlists"
 msgstr "재생 목록"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "최근에 추가"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "비디오"
--- a/po/minidlna.pot
+++ b/po/minidlna.pot
@@ -84,6 +84,10 @@ msgstr ""
 msgid "Playlists"
 msgstr ""
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr ""
+
 #: scanner.c:536
 msgid "Video"
 msgstr ""
--- a/po/nb.po
+++ b/po/nb.po
@@ -68,6 +68,10 @@ msgstr "Mapper"
 msgid "Playlists"
 msgstr "Spillelister"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "Nylig lagt til"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Video"
--- a/po/nl.po
+++ b/po/nl.po
@@ -68,6 +68,10 @@ msgstr "Mappen"
 msgid "Playlists"
 msgstr "Afspeellijst"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "Nyligen tillagd"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Video"
--- a/po/pl.po
+++ b/po/pl.po
@@ -83,6 +83,10 @@ msgstr "Folder"
 msgid "Playlists"
 msgstr "Lista Utworow"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "Niedawno dodane"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Filmy"
--- a/po/ru.po
+++ b/po/ru.po
@@ -85,6 +85,10 @@ msgstr "Папки"
 msgid "Playlists"
 msgstr "Списки Воспроизведения"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr ""
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Видео"
--- a/po/sl.po
+++ b/po/sl.po
@@ -83,6 +83,10 @@ msgstr "Mape"
 msgid "Playlists"
 msgstr "Seznami predvajanj"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "nedavno dodano"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Video"
--- a/po/sv.po
+++ b/po/sv.po
@@ -68,6 +68,10 @@ msgstr "Mappar"
 msgid "Playlists"
 msgstr "Spelningslistor"
 
+#: scanner.c:598
+msgid "Recently Added"
+msgstr "nyligen tillagda"
+
 #: scanner.c:536
 msgid "Video"
 msgstr "Film"
--- a/process.c
+++ b/process.c
@@ -96,10 +96,10 @@ process_fork(struct client_cache_s *clie
 	pid_t pid = fork();
 	if (pid > 0)
 	{
-		number_of_children++;
 		if (client)
 			client->connections++;
 		add_process_info(pid, client);
+		number_of_children++;
 	}
 
 	return pid;
--- a/scanner.c
+++ b/scanner.c
@@ -594,7 +594,8 @@ CreateDatabase(void)
 			ret = sql_exec(db, "INSERT into OBJECTS (OBJECT_ID, PARENT_ID, DETAIL_ID, CLASS, NAME)"
 			                   " values "
 					   "('%s', '%s', %lld, 'container.storageFolder', '%q')",
-					   magic->objectid_match, parent, GetFolderMetadata(magic->name, NULL, NULL, NULL, 0), magic->name);
+					   magic->objectid_match, parent,
+					   GetFolderMetadata(_(magic->name), NULL, NULL, NULL, 0), _(magic->name));
 			free(parent);
 			if( ret != SQLITE_OK )
 				goto sql_failed;
--- a/testupnpdescgen.c
+++ b/testupnpdescgen.c
@@ -40,9 +40,6 @@ char modelname[] = "MiniDLNA";
 char modelnumber[] = "1";
 char presentationurl[] = "http://192.168.0.1:8080/";
 unsigned int updateID = 0;
-#if PNPX
-char pnpx_hwid[] = "VEN_01F2&amp;DEV_0101&amp;REV_01 VEN_0033&amp;DEV_0001&amp;REV_01";
-#endif
 
 int getifaddr(const char * ifname, char * buf, int len)
 {
--- a/upnpdescgen.c
+++ b/upnpdescgen.c
@@ -115,29 +115,17 @@ static const char xmlver[] =
 static const char root_service[] =
 	"scpd xmlns=\"urn:schemas-upnp-org:service-1-0\"";
 static const char root_device[] = 
-	"root xmlns=\"urn:schemas-upnp-org:device-1-0\""
-#if PNPX
-	" xmlns:pnpx=\"http://schemas.microsoft.com/windows/pnpx/2005/11\""
-	" xmlns:df=\"http://schemas.microsoft.com/windows/2008/09/devicefoundation\""
-#endif
-	;
+	"root xmlns=\"urn:schemas-upnp-org:device-1-0\"";
 
 /* root Description of the UPnP Device */
 static const struct XMLElt rootDesc[] =
 {
 	{root_device, INITHELPER(1,2)},
 	{"specVersion", INITHELPER(3,2)},
-	{"device", INITHELPER(5,(14+PNPX))},
+	{"device", INITHELPER(5,(14))},
 	{"/major", "1"},
 	{"/minor", "0"},
 	{"/deviceType", "urn:schemas-upnp-org:device:MediaServer:1"},
-#if PNPX == 5
-	{"/pnpx:X_hardwareId", pnpx_hwid},
-	{"/pnpx:X_compatibleId", "MS_DigitalMediaDeviceClass_DMS_V001"},
-	{"/pnpx:X_deviceCategory", "MediaDevices"},
-	{"/df:X_deviceCategory", "Multimedia.DMS"},
-	{"/microsoft:magicPacketWakeSupported xmlns:microsoft=\"urn:schemas-microsoft-com:WMPNSS-1-0\"", "0"},
-#endif
 	{"/friendlyName", friendly_name},	/* required */
 	{"/manufacturer", ROOTDEV_MANUFACTURER},		/* required */
 	{"/manufacturerURL", ROOTDEV_MANUFACTURERURL},	/* optional */
@@ -149,12 +137,12 @@ static const struct XMLElt rootDesc[] =
 	{"/UDN", uuidvalue},	/* required */
 	{"/dlna:X_DLNADOC xmlns:dlna=\"urn:schemas-dlna-org:device-1-0\"", "DMS-1.50"},
 	{"/presentationURL", presentationurl},	/* recommended */
-	{"iconList", INITHELPER((19+PNPX),4)},
-	{"serviceList", INITHELPER((43+PNPX),3)},
-	{"icon", INITHELPER((23+PNPX),5)},
-	{"icon", INITHELPER((28+PNPX),5)},
-	{"icon", INITHELPER((33+PNPX),5)},
-	{"icon", INITHELPER((38+PNPX),5)},
+	{"iconList", INITHELPER((19),4)},
+	{"serviceList", INITHELPER((43),3)},
+	{"icon", INITHELPER((23),5)},
+	{"icon", INITHELPER((28),5)},
+	{"icon", INITHELPER((33),5)},
+	{"icon", INITHELPER((38),5)},
 	{"/mimetype", "image/png"},
 	{"/width", "48"},
 	{"/height", "48"},
@@ -175,9 +163,9 @@ static const struct XMLElt rootDesc[] =
 	{"/height", "120"},
 	{"/depth", "24"},
 	{"/url", "/icons/lrg.jpg"},
-	{"service", INITHELPER((46+PNPX),5)},
-	{"service", INITHELPER((51+PNPX),5)},
-	{"service", INITHELPER((56+PNPX),5)},
+	{"service", INITHELPER((46),5)},
+	{"service", INITHELPER((51),5)},
+	{"service", INITHELPER((56),5)},
 	{"/serviceType", "urn:schemas-upnp-org:service:ContentDirectory:1"},
 	{"/serviceId", "urn:upnp-org:serviceId:ContentDirectory"},
 	{"/controlURL", CONTENTDIRECTORY_CONTROLURL},
@@ -584,10 +572,10 @@ genRootDescSamsung(int * len)
 	memcpy(str, xmlver, *len + 1);
 	/* Replace the optional modelURL and manufacturerURL fields with Samsung foo */
 	memcpy(&samsungRootDesc, &rootDesc, sizeof(rootDesc));
-	samsungRootDesc[8+PNPX].eltname = "/sec:ProductCap";
-	samsungRootDesc[8+PNPX].data = "smi,DCM10,getMediaInfo.sec,getCaptionInfo.sec";
-	samsungRootDesc[12+PNPX].eltname = "/sec:X_ProductCap";
-	samsungRootDesc[12+PNPX].data = "smi,DCM10,getMediaInfo.sec,getCaptionInfo.sec";
+	samsungRootDesc[8].eltname = "/sec:ProductCap";
+	samsungRootDesc[8].data = "smi,DCM10,getMediaInfo.sec,getCaptionInfo.sec";
+	samsungRootDesc[12].eltname = "/sec:X_ProductCap";
+	samsungRootDesc[12].data = "smi,DCM10,getMediaInfo.sec,getCaptionInfo.sec";
 	str = genXML(str, len, &tmplen, samsungRootDesc);
 	str[*len] = '\0';
 	return str;
--- a/upnpglobalvars.c
+++ b/upnpglobalvars.c
@@ -66,9 +66,6 @@ char uuidvalue[] = "uuid:00000000-0000-0
 char modelname[MODELNAME_MAX_LEN] = ROOTDEV_MODELNAME;
 char modelnumber[MODELNUMBER_MAX_LEN] = MINIDLNA_VERSION;
 char serialnumber[SERIALNUMBER_MAX_LEN] = "00000000";
-#if PNPX
-char pnpx_hwid[] = "VEN_0000&amp;DEV_0000&amp;REV_01 VEN_0033&amp;DEV_0001&amp;REV_01";
-#endif
 
 /* presentation url :
  * http://nnn.nnn.nnn.nnn:ppppp/  => max 30 bytes including terminating 0 */
--- a/upnpglobalvars.h
+++ b/upnpglobalvars.h
@@ -57,7 +57,7 @@
 
 #include <sqlite3.h>
 
-#define MINIDLNA_VERSION "1.1.5"
+#define MINIDLNA_VERSION "1.1.6"
 
 #ifdef NETGEAR
 # define SERVER_NAME "ReadyDLNA"
@@ -75,10 +75,6 @@
 #endif
 #define THISORNUL(s) (s ? s : "")
 
-#ifndef PNPX
-#define PNPX 0
-#endif
-
 #define RESOURCE_PROTOCOL_INFO_VALUES \
 	"http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_TN," \
 	"http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_SM," \
@@ -191,6 +187,7 @@ extern uint32_t runtime_flags;
 #define NO_PLAYLIST_MASK      0x0008
 #define SYSTEMD_MASK          0x0010
 #define MERGE_MEDIA_DIRS_MASK 0x0020
+#define WIDE_LINKS_MASK       0x0040
 
 #define SETFLAG(mask)	runtime_flags |= mask
 #define GETFLAG(mask)	(runtime_flags & mask)
@@ -212,10 +209,6 @@ extern char serialnumber[];
 #define PRESENTATIONURL_MAX_LEN 64
 extern char presentationurl[];
 
-#if PNPX
-extern char pnpx_hwid[];
-#endif
-
 /* lan addresses */
 extern int n_lan_addr;
 extern struct lan_addr_s lan_addr[];
--- a/upnphttp.c
+++ b/upnphttp.c
@@ -477,6 +477,21 @@ Send400(struct upnphttp * h)
 	CloseSocket_upnphttp(h);
 }
 
+/* very minimalistic 403 error message */
+static void
+Send403(struct upnphttp * h)
+{
+	static const char body403[] =
+		"<HTML><HEAD><TITLE>403 Forbidden</TITLE></HEAD>"
+		"<BODY><H1>Forbidden</H1>You don't have permission to access this resource."
+		"</BODY></HTML>\r\n";
+	h->respflags = FLAG_HTML;
+	BuildResp2_upnphttp(h, 403, "Forbidden",
+	                    body403, sizeof(body403) - 1);
+	SendResp_upnphttp(h);
+	CloseSocket_upnphttp(h);
+}
+
 /* very minimalistic 404 error message */
 static void
 Send404(struct upnphttp * h)
@@ -812,12 +827,6 @@ ProcessHttpQuery_upnphttp(struct upnphtt
 	HttpCommand[i] = '\0';
 	while(*p==' ')
 		p++;
-	if(strncmp(p, "http://", 7) == 0)
-	{
-		p = p+7;
-		while(*p!='/')
-			p++;
-	}
 	for(i = 0; i<511 && *p && *p != ' ' && *p != '\r'; i++)
 		HttpUrl[i] = *(p++);
 	HttpUrl[i] = '\0';
@@ -1328,6 +1337,46 @@ start_dlna_header(struct string_s *str,
 	             respcode, date, tmode, mime);
 }
 
+static int
+_open_file(const char *orig_path)
+{
+	struct media_dir_s *media_path;
+	char buf[PATH_MAX];
+	const char *path;
+	int fd;
+
+	if (!GETFLAG(WIDE_LINKS_MASK))
+	{
+		path = realpath(orig_path, buf);
+		if (!path)
+		{
+			DPRINTF(E_ERROR, L_HTTP, "Error resolving path %s: %s\n",
+						orig_path, strerror(errno));
+			return -1;
+		}
+
+		for (media_path = media_dirs; media_path; media_path = media_path->next)
+		{
+			if (strncmp(path, media_path->path, strlen(media_path->path)) == 0)
+				break;
+		}
+               if (!media_path && strncmp(path, db_path, strlen(db_path)))
+		{
+			DPRINTF(E_ERROR, L_HTTP, "Rejecting wide link %s -> %s\n",
+						orig_path, path);
+			return -403;
+		}
+	}
+	else
+		path = orig_path;
+
+	fd = open(path, O_RDONLY);
+	if (fd < 0)
+		DPRINTF(E_ERROR, L_HTTP, "Error opening %s\n", path);
+
+	return fd;
+}
+
 static void
 SendResp_icon(struct upnphttp * h, char * icon)
 {
@@ -1413,11 +1462,13 @@ SendResp_albumArt(struct upnphttp * h, c
 	}
 	DPRINTF(E_INFO, L_HTTP, "Serving album art ID: %lld [%s]\n", id, path);
 
-	fd = open(path, O_RDONLY);
+	fd = _open_file(path);
 	if( fd < 0 ) {
-		DPRINTF(E_ERROR, L_HTTP, "Error opening %s\n", path);
 		sqlite3_free(path);
-		Send404(h);
+		if (fd == -403)
+			Send403(h);
+		else
+			Send404(h);
 		return;
 	}
 	sqlite3_free(path);
@@ -1461,11 +1512,13 @@ SendResp_caption(struct upnphttp * h, ch
 	}
 	DPRINTF(E_INFO, L_HTTP, "Serving caption ID: %lld [%s]\n", id, path);
 
-	fd = open(path, O_RDONLY);
+	fd = _open_file(path);
 	if( fd < 0 ) {
-		DPRINTF(E_ERROR, L_HTTP, "Error opening %s\n", path);
 		sqlite3_free(path);
-		Send404(h);
+		if (fd == -403)
+			Send403(h);
+		else
+			Send404(h);
 		return;
 	}
 	sqlite3_free(path);
@@ -1914,10 +1967,12 @@ SendResp_dlnafile(struct upnphttp *h, ch
 	}
 
 	offset = h->req_RangeStart;
-	sendfh = open(last_file.path, O_RDONLY);
+	sendfh = _open_file(last_file.path);
 	if( sendfh < 0 ) {
-		DPRINTF(E_ERROR, L_HTTP, "Error opening %s\n", last_file.path);
-		Send404(h);
+		if (sendfh == -403)
+			Send403(h);
+		else
+			Send404(h);
 		goto error;
 	}
 	size = lseek(sendfh, 0, SEEK_END);
--- a/upnpsoap.c
+++ b/upnpsoap.c
@@ -1055,6 +1055,7 @@ callback(void *args, int argc, char **ar
 					break;
 				case ESamsungSeriesCDE:
 				case ELGDevice:
+				case ELGNetCastDevice:
 				case EAsusOPlay:
 				default:
 					if( passed_args->flags & FLAG_HAS_CAPTIONS )
@@ -1064,7 +1065,7 @@ callback(void *args, int argc, char **ar
 									     "http://%s:%d/Captions/%s.srt"
 									   "&lt;/res&gt;",
 									   lan_addr[passed_args->iface].str, runtime_vars.port, detailID);
-						else if( passed_args->filter & FILTER_SEC_CAPTION_INFO_EX )
+						if( passed_args->filter & FILTER_SEC_CAPTION_INFO_EX )
 							ret = strcatf(str, "&lt;sec:CaptionInfoEx sec:type=\"srt\"&gt;"
 							                     "http://%s:%d/Captions/%s.srt"
 							                   "&lt;/sec:CaptionInfoEx&gt;",
@@ -1924,14 +1925,21 @@ SamsungSetBookmark(struct upnphttp * h,
 	ParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data, 0);
 	ObjectID = GetValueFromNameValueList(&data, "ObjectID");
 	PosSecond = GetValueFromNameValueList(&data, "PosSecond");
+
+	if ( atoi(PosSecond) < 30 )
+		PosSecond = "0";
+
 	if( ObjectID && PosSecond )
 	{
 		int ret;
+		const char *rid = ObjectID;
+
+		in_magic_container(ObjectID, 0, &rid);
 		ret = sql_exec(db, "INSERT OR REPLACE into BOOKMARKS"
 		                   " VALUES "
-		                   "((select DETAIL_ID from OBJECTS where OBJECT_ID = '%q'), %q)", ObjectID, PosSecond);
+		                   "((select DETAIL_ID from OBJECTS where OBJECT_ID = '%q'), %q)", rid, PosSecond);
 		if( ret != SQLITE_OK )
-			DPRINTF(E_WARN, L_METADATA, "Error setting bookmark %s on ObjectID='%s'\n", PosSecond, ObjectID);
+			DPRINTF(E_WARN, L_METADATA, "Error setting bookmark %s on ObjectID='%s'\n", PosSecond, rid);
 		BuildSendAndCloseSoapResp(h, resp, sizeof(resp)-1);
 	}
 	else
