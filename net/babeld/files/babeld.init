#!/bin/sh /etc/rc.common

. /lib/functions/network.sh

START=70

pidfile='/var/run/babeld.pid'
CONFIGFILE='/var/etc/babeld.conf'
OTHERCONFIGFILE="/etc/babeld.conf"
EXTRA_COMMANDS="status"
EXTRA_HELP="        status Dump Babel's table to the log file."

# Append a line to the configuration file
cfg_append() {
        local value="$1"
        echo "$value" >> $CONFIGFILE
}

cfg_append_option() {
	local section="$1"
	local option="$2"
	local value
	config_get value "$section" "$option"
	# babeld convention for options is '-', not '_'
	[ -n "$value" ] && cfg_append "${option//_/-} $value"
}

# Append to the "$buffer" variable
append_ifname() {
	local section="$1"
	local option="$2"
	local switch="$3"
	local _name
	config_get _name "$section" "$option"
	[ -z "$_name" ] && return 0
	local ifname=$(uci_get_state network "$_name" ifname "$_name")
	append buffer "$switch $ifname"
}

append_bool() {
	local section="$1"
	local option="$2"
	local value="$3"
	local _loctmp
	config_get_bool _loctmp "$section" "$option" 0
	[ "$_loctmp" -gt 0 ] && append buffer "$value"
}

append_parm() {
	local section="$1"
	local option="$2"
	local switch="$3"
	local _loctmp
	config_get _loctmp "$section" "$option"
	[ -z "$_loctmp" ] && return 0
	append buffer "$switch $_loctmp"
}

babel_filter() {
	local cfg="$1"
	local _loctmp

	local _ignored
	config_get_bool _ignored "$cfg" 'ignore' 0
	[ "$_ignored" -eq 1 ] && return 0

	unset buffer
	append_parm "$cfg" 'type' ''

	append_bool "$cfg" 'local' 'local'

	append_parm "$cfg" 'ip' 'ip'
	append_parm "$cfg" 'eq' 'eq'
	append_parm "$cfg" 'le' 'le'
	append_parm "$cfg" 'ge' 'ge'
	append_parm "$cfg" 'neigh' 'neigh'
	append_parm "$cfg" 'id' 'id'
	append_parm "$cfg" 'proto' 'proto'

	append_ifname "$cfg" 'if' 'if'

	append_parm "$cfg" 'action' ''

	cfg_append "$buffer"
}

# Only one of babeld's options is allowed multiple times, "import-table".
# We just append it multiple times.
list_cb() {
	option_cb "$@"
}

config_cb() {
	local type="$1"
	local section="$2"
	case "$type" in
	"general")
		option_cb() {
			local option="$1"
			local value="$2"
			cfg_append "${option//_/-} $value"
		}
	;;
	"interface")
		unset interface
		network_get_device interface "$section" || interface="$section"
		option_cb() {
			local option="$1"
			local value="$2"
			cfg_append "interface $interface ${option//_/-} $value"
		}
		# Also include an empty "interface $interface" statement, so
		# that babeld operates on this interface.
		cfg_append "interface $interface"
	;;
	*)
		# Don't use reset_cb, this would also reset config_cb
		option_cb() { return; }
	;;
	esac
}

start() {
	mkdir -p /var/lib
	# Start by emptying the generated config file
	>"$CONFIGFILE"
	# Parse general and interface sections thanks to the "config_cb()"
	# callback.  This allows to loop over all options without having to
	# know their name in advance.
	config_load babeld
	# Parse filters separately, since we know which options we expect
	config_foreach babel_filter filter
	# Using multiple config files is supported since babeld 1.5.1
	/usr/sbin/babeld -D -I "$pidfile" -c "$OTHERCONFIGFILE" -c "$CONFIGFILE"
	# Wait for the pidfile to appear
	for i in 1 2
	do
		[ -f "$pidfile" ] || sleep 1
	done
	[ -f "$pidfile" ] || (echo "Failed to start babeld"; exit 42)
}

stop() {
	[ -f "$pidfile" ] && kill $(cat $pidfile)
  # avoid race-condition on restart: wait for
  # babeld to die for real.
  [ -f "$pidfile" ] && sleep 1
  [ -f "$pidfile" ] && sleep 1
  [ -f "$pidfile" ] && sleep 1
  [ -f "$pidfile" ] && exit 42
}

status() {
	[ -f "$pidfile" ] && kill -USR1 $(cat $pidfile)
}
