Index: arpwatch-2.1a15/arpwatch.8
===================================================================
--- arpwatch-2.1a15.orig/arpwatch.8
+++ arpwatch-2.1a15/arpwatch.8
@@ -88,6 +88,12 @@ arpwatch - keep track of ethernet/ip add
 .br
 .ti +8
 [
+.B -P
+.I pid_path
+]
+.br
+.ti +9
+[
 .B -a
 ]
 .br
@@ -204,6 +210,10 @@ setting promiscuous mode does not mean g
 YMMV. (This feature comes from Debian).
 .LP
 The
+.B -P
+flag is used to specify pid filename. Default is set to /var/run/arpwatch.pid.
+.LP
+The
 .B -a
 flag tells
 .B arpwatch
Index: arpwatch-2.1a15/arpwatch.h
===================================================================
--- arpwatch-2.1a15.orig/arpwatch.h
+++ arpwatch-2.1a15/arpwatch.h
@@ -1,6 +1,7 @@
 /* @(#) $Id: arpwatch.h,v 1.29 2000/09/30 23:40:49 leres Exp $ (LBL) */
 
 #define ARPFILE "arp.dat"
+#define PIDFILENAME "/var/run/arpwatch.pid"
 /*#define ETHERCODES "ethercodes.dat" */
 #define CHECKPOINT (15*60)		/* Checkpoint time in seconds */
 
Index: arpwatch-2.1a15/arpwatch.c
===================================================================
--- arpwatch-2.1a15.orig/arpwatch.c
+++ arpwatch-2.1a15/arpwatch.c
@@ -108,6 +108,8 @@ struct rtentry;
 
 char *prog;
 char *path_sendmail = PATH_SENDMAIL;
+char *pidname = PIDFILENAME;
+int nofork = 0;
 
 int can_checkpoint;
 int swapped;
@@ -237,7 +239,6 @@ main(int argc, char **argv)
 	struct bpf_program code;
 	char errbuf[PCAP_ERRBUF_SIZE];
 	char* username = NULL;
-	int nofork = 0;
 	int restart = 0;
 	int restarting_loop = 0;
 	char options[] =
@@ -252,6 +253,7 @@ main(int argc, char **argv)
 		"m:"
 		"s:"
 		"p"
+		"P:"
 		"a"
 		"u:"
 		"R:"
@@ -260,6 +262,7 @@ main(int argc, char **argv)
 		"z:"
 	;
 	char *tmpptr;
+	FILE *pidfile;
 
 	if (argv[0] == NULL)
 		prog = "arpwatch";
@@ -332,6 +335,10 @@ main(int argc, char **argv)
 			++nopromisc;
 			break;
 
+		case 'P':
+			pidname = optarg;
+			break;
+
 		case 'a':
 			++allsubnets;
 			break;
@@ -400,6 +407,15 @@ main(int argc, char **argv)
 					exit(1);
 				} else if (pid != 0)
 					exit(0);
+				pidfile = fopen(pidname, "w");
+				if(pidfile) {
+					int pid = (int)getpid();
+					fprintf(pidfile, "%d\n", pid);
+					fclose(pidfile);
+					syslog(LOG_INFO, "Wrote pid %d to %s", pid, pidname);
+				}
+				else
+					fprintf(stderr, "Couldn't write pid file\n");
 			}
 			(void)close(fileno(stdin));
 			(void)close(fileno(stdout));
@@ -928,6 +944,9 @@ die(int signo)
 {
 
 	syslog(LOG_DEBUG, "exiting");
+	if (!debug && !nofork)
+		if(!unlink(pidname))
+			syslog(LOG_DEBUG, "unable to remove pid file %s", pidname);
 	checkpoint(0);
 	exit(1);
 }
