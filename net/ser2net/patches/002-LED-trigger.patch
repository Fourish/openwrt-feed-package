From 467bc7b7224a9e078b28fe15ded3f5368efb2fcc Mon Sep 17 00:00:00 2001
From: Michael Heimpold <michael.heimpold@i2se.com>
Date: Wed, 22 Apr 2015 13:35:43 +0200
Subject: [PATCH v3] Add support for triggering LEDs during serial traffic

This adds the possibility to flash an LED when serial traffic is
detected. This is based on Linux's kernel led transient trigger.
The idea is to provide some kind of traffic indicator
like the flashing LEDs on e.g. network card.

It is possible to define different LEDs for both tx and rx directions,
and for one/multiple ports.

This changeset is targetting embedded devices with dedicated LEDs
running ser2net, however, you can also use the numlock/caps lock leds
of you keyboard to test.

Signed-off-by: Michael Heimpold <michael.heimpold@i2se.com>
Cc: Corey Minyard <minyard@acm.org>

---

Hi,

once upon the time, I sent the last version of this patch and then got busy with
family stuff :-) Anyway, this is now v3, including improvements based on your
feedback, see below.

A question was, whether I tested it with config reload: yes it works(tm) :-),
but only after an actual connection is closed and then when re-opend the new
settings apply.


v3:
- rebased to current git head
- build time switch added to enabled this feature (disabled by default
  to stay backwards compatible)
- examples are commented out (feature might be not available)
- check for trigger availability
- busy waiting for trigger configuration files to appear

v2:
- rebased to current git head
- extended commit message

v1:
- initial submission to mailing list


 Makefile.am  |   4 +-
 configure.ac |   7 ++++
 dataxfer.c   |  30 +++++++++++++++
 readconfig.c | 112 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 ser2net.8    |  16 ++++++++
 ser2net.conf |  15 +++++++-
 sysfs_led.c  | 118 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 sysfs_led.h  |  11 ++++++
 utils.c      |   3 ++
 utils.h      |   3 ++
 10 files changed, 316 insertions(+), 3 deletions(-)
 create mode 100644 sysfs_led.c
 create mode 100644 sysfs_led.h

--- a/Makefile.am
+++ b/Makefile.am
@@ -2,9 +2,9 @@ sbin_PROGRAMS = ser2net
 ACLOCAL_AMFLAGS = -I m4
 AM_CFLAGS=-Wall
 ser2net_SOURCES = controller.c dataxfer.c devcfg.c readconfig.c selector.c \
-	ser2net.c utils.c telnet.c buffer.c
+	ser2net.c utils.c telnet.c buffer.c sysfs_led.c
 noinst_HEADERS = controller.h dataxfer.h devio.h readconfig.h selector.h \
-	utils.h telnet.h buffer.h ser2net.h
+	utils.h telnet.h buffer.h sysfs_led.h ser2net.h
 man_MANS = ser2net.8
 EXTRA_DIST = $(man_MANS) ser2net.conf ser2net.spec ser2net.init
 
--- a/configure.ac
+++ b/configure.ac
@@ -18,6 +18,13 @@ then
   AC_HAVE_HEADERS(tcpd.h)
   AC_CHECK_LIB(wrap,main)
 fi
+AC_ARG_WITH(led-support,
+ [  --with-led-support      Enable LED support (Linux only)],
+ led_support_flag="$withval",
+ led_support_flag=no)
+if test "$led_support_flag" != no; then
+  AC_DEFINE(USE_LED_FEATURE)
+fi
 
 # enable silent build
 m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
--- a/dataxfer.c
+++ b/dataxfer.c
@@ -43,6 +43,7 @@
 #include "telnet.h"
 #include "devio.h"
 #include "buffer.h"
+#include "sysfs_led.h"
 
 #define SERIAL "term"
 #define NET    "tcp "
@@ -248,6 +249,14 @@ typedef struct port_info
 #ifdef USE_RS485_FEATURE
     struct serial_rs485 *rs485conf;
 #endif
+
+#ifdef USE_LED_FEATURE
+    /*
+     * LED names to flash for serial traffic
+     */
+    char *led_tx;
+    char *led_rx;
+#endif
 } port_info_t;
 
 port_info_t *ports = NULL; /* Linked list of ports. */
@@ -329,6 +338,10 @@ init_port_data(port_info_t *port)
 #ifdef USE_RS485_FEATURE
     port->rs485conf = NULL;
 #endif
+#ifdef USE_LED_FEATURE
+    port->led_tx = NULL;
+    port->led_rx = NULL;
+#endif
 }
 
 static void
@@ -566,6 +579,11 @@ handle_dev_fd_read(struct devio *io)
 	/* Do both tracing, ignore errors. */
 	do_trace(port, port->tb, port->dev_to_tcp.buf, count, SERIAL);
 
+#if USE_LED_FEATURE
+    if (port->led_rx)
+	led_blink_kick(port->led_rx);
+#endif
+
     port->dev_bytes_received += count;
 
     if (port->enabled == PORT_TELNET) {
@@ -798,6 +816,10 @@ handle_tcp_fd_read(int fd, void *data)
 	    return;
 	}
     } else {
+#if USE_LED_FEATURE
+	if (port->led_tx)
+	    led_blink_kick(port->led_tx);
+#endif
 	port->dev_bytes_sent += count;
 	port->tcp_to_dev.cursize -= count;
 	if (port->tcp_to_dev.cursize != 0) {
@@ -1939,6 +1961,14 @@ myconfig(void *data, struct absout *eout
     } else if (strncmp(pos, "tb=", 3) == 0) {
 	/* trace both directions. */
 	port->trace_both.filename = find_tracefile(pos + 3);
+#if USE_LED_FEATURE
+    } else if (strncmp(pos, "led-rx=", 7) == 0) {
+	/* LED for UART RX traffic */
+	port->led_rx = find_led(pos + 7);
+    } else if (strncmp(pos, "led-tx=", 7) == 0) {
+	/* LED for UART TX traffic */
+	port->led_tx = find_led(pos + 7);
+#endif
 #ifdef USE_RS485_FEATURE
     } else if (strncmp(pos, "rs485=", 6) == 0) {
 	/* get RS485 configuration. */
--- a/readconfig.c
+++ b/readconfig.c
@@ -32,6 +32,7 @@
 #include "readconfig.h"
 #include "utils.h"
 #include "telnet.h"
+#include "sysfs_led.h"
 
 #define MAX_LINE_SIZE 256	/* Maximum line length in the config file. */
 
@@ -482,6 +483,97 @@ free_rs485confs(void)
 }
 #endif
 
+#ifdef USE_LED_FEATURE
+struct led_s
+{
+    char *name;
+    char *device;
+    unsigned int duration;
+    struct led_s *next;
+};
+
+/* all LEDs in the system. */
+struct led_s *leds = NULL;
+
+static void
+handle_led(char *name, char *cfg)
+{
+    struct led_s *new_led;
+    char devicename[256];
+
+    new_led = malloc(sizeof(*new_led));
+    if (!new_led) {
+	syslog(LOG_ERR, "Out of memory handling led on %d", lineno);
+	return;
+    }
+
+    new_led->name = strdup(name);
+    if (!new_led->name) {
+	syslog(LOG_ERR, "Out of memory handling led on %d", lineno);
+	free(new_led);
+	return;
+    }
+
+    if (sscanf(cfg, "%256s %u", devicename, &new_led->duration) != 2) {
+	syslog(LOG_ERR, "Couldn't parse led config on %d", lineno);
+	free(new_led->name);
+	free(new_led);
+	return;
+    }
+
+    new_led->device = strdup(devicename);
+    if (!new_led->device) {
+	syslog(LOG_ERR, "Out of memory handling led on %d", lineno);
+	free(new_led->name);
+	free(new_led);
+	return;
+    }
+
+    /* setup the led */
+    if (led_blink_prepare(new_led->device, new_led->duration) != 0) {
+	syslog(LOG_ERR, "Could not prepare transient trigger for led '%s'",
+	       new_led->device);
+	free(new_led->name);
+	free(new_led);
+	return;
+    }
+
+    new_led->next = leds;
+    leds = new_led;
+}
+
+char *
+find_led(const char *name)
+{
+    struct led_s *led = leds;
+
+    while (led) {
+	if (strcmp(name, led->name) == 0)
+	    return strdup(led->device);
+	led = led->next;
+    }
+    syslog(LOG_ERR, "Led '%s' not found, it will be ignored", name);
+    return NULL;
+}
+
+static void
+free_leds(void)
+{
+    struct led_s *led;
+
+    while (leds) {
+	led = leds;
+	leds = leds->next;
+
+	led_off(led->device);
+
+	free(led->name);
+	free(led->device);
+	free(led);
+    }
+}
+#endif /* USE_LED_FEATURE */
+
 static int
 startswith(char *str, const char *test, char **strtok_data)
 {
@@ -635,6 +727,23 @@ handle_config_line(char *inbuf)
 	return;
     }
 
+#ifdef USE_LED_FEATURE
+    if (startswith(inbuf, "LED", &strtok_data)) {
+	char *name = strtok_r(NULL, ":", &strtok_data);
+	char *str = strtok_r(NULL, "\n", &strtok_data);
+	if (name == NULL) {
+	    syslog(LOG_ERR, "No LED name given on line %d", lineno);
+	    return;
+	}
+	if ((str == NULL) || (strlen(str) == 0)) {
+	    syslog(LOG_ERR, "No LED given on line %d", lineno);
+	    return;
+	}
+	handle_led(name, str);
+	return;
+    }
+#endif
+
     comma = strchr(inbuf, ',');
     if (comma) {
 	if (!strtok_r(comma, ":", &strtok_data)) {
@@ -700,6 +809,9 @@ readconfig(char *filename)
 #ifdef USE_RS485_FEATURE
     free_rs485confs();
 #endif
+#ifdef USE_LED_FEATURE
+    free_leds();
+#endif
 
     config_num++;
 
--- a/ser2net.8
+++ b/ser2net.8
@@ -204,6 +204,10 @@ or
 .IP
 CONTROLPORT:<port spec>
 .PP
+or
+.IP
+LED:<led-name>:<sysfs-led-filename> <delay>
+.PP
 
 .SS FIELDS
 .TP
@@ -324,6 +328,12 @@ May be combined with [-]timestamp.  Orde
 causes a telnet sync operation to send a break.  By default data is
 flushed until the data mark, but no break is sent.
 
+.I led-tx=<led-name>
+use the previously defined led to indicate serial tx traffic on this port
+
+.I led-rx=<led-name>
+use the previously defined led to indicate serial rx traffic on this port
+
 .TP
 .I "banner name"
 A name for the banner; this may be used in the options of a port.
@@ -350,6 +360,12 @@ The control port specification as define
 command line.  This lets the control port be specified in the configuration
 file.  The command line will override this, and only the first port
 specified is used.
+.TP
+.I "led"
+Define an led with given name. This uses a Linux's led class device
+(/sys/class/leds/<led-sysfs-filename>) and configures it for transient led
+trigger with the given delay time. Individual TCP ports can refer to
+this led and thus trigger flashing of this led when tx/rx traffic is seen.
 
 .PP
 Blank lines and lines starting with `#' are ignored.
--- a/ser2net.conf
+++ b/ser2net.conf
@@ -60,7 +60,9 @@
 #            the device, and tb is both.
 #            The telnet_brk_on_sync option causes a telnet sync
 #            operation to send a break.  By default data is flushed
-#	     until the data mark, but no break is sent.
+#            until the data mark, but no break is sent.
+#            The "led-tx" and "led-rx" options allow to specify
+#            an LED defined above to trigger for traffic.
 #
 # or...
 
@@ -87,6 +89,12 @@
 #    This specifies a filename to trace output into, as tw=/tmp/trace1.
 #    This takes the same escape sequences as banners.
 #
+#  LED:<name>:sysfs-filename duration
+#    This specifies an LED which will be configured to use linux's transient trigger.
+#    The LED is always kicked when traffic is detected on serial side. The duration
+#    is given in milliseconds. See Linux's documentation for transient trigger for
+#    details.
+#
 #  OPENSTR:<name>:str
 #    This specifies a string to be transmitted to the device when the
 #    port is opened.  This takes the same escape sequences as banners.
@@ -123,6 +131,9 @@ SIGNATURE:signature1:ser2net port ttyS2
 
 RS485CONF:rs485port1:0:0:0:0
 
+#LED:rx:duckbill:green:rs485 10
+#LED:tx:duckbill:red:rs485 10
+
 TRACEFILE:tw1:/tmp/tw-\p-\Y-\M-\D-\H:\i:\s.\U
 TRACEFILE:tr1:/tmp/tr-\p-\Y-\M-\D-\H:\i:\s.\U
 
@@ -156,3 +167,5 @@ CLOSEON:closehtml:</html>
 
 3020:telnet:0:/dev/ttyUSB0:9600 banner1 remctl telnet_brk_on_sync
 3021:telnet:0:/dev/ttyUSB1:9600 banner2 open1 close1 remctl closehtml
+
+#5000:telnet:0:/dev/ttyAPP0:9600 NONE 1STOPBIT 8DATABITS -XONXOFF LOCAL -RTSCTS led-tx=tx led-rx=rx
--- /dev/null
+++ b/sysfs_led.c
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2015 I2SE GmbH
+ * Copyright (C) 2016 Michael Heimpold <mhei@heimpold.de>
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+
+#define SYSFS_LED_BASE "/sys/class/leds"
+
+#ifdef USE_LED_FEATURE
+
+#define BUFSIZE 4096
+
+static int led_is_trigger_missing(const char *led)
+{
+    char *buffer, *trigger;
+    int fd, c;
+
+    buffer = malloc(BUFSIZE);
+    if (!buffer)
+	return -1;
+
+    snprintf(buffer, BUFSIZE, "%s/%s/trigger", SYSFS_LED_BASE, led);
+
+    if ((fd = open(buffer, O_RDONLY)) == -1) {
+	free(buffer);
+	return -1;
+    }
+
+    if ((c = read(fd, buffer, BUFSIZE)) <= 0) {
+	free(buffer);
+	close(fd);
+	return -1;
+    }
+
+    if (close(fd) < 0) {
+	free(buffer);
+	return -1;
+    }
+
+    buffer[c] = '\0';
+    trigger = strstr(buffer, "transient");
+    free(buffer);
+    return trigger == NULL;
+}
+
+static int led_write(const char *led, const char *property, const char *buf)
+{
+    char filename[255];
+    int fd;
+
+    snprintf(filename, sizeof(filename), "%s/%s/%s", SYSFS_LED_BASE, led, property);
+
+    if ((fd = open(filename, O_WRONLY | O_TRUNC)) == -1)
+	return -1;
+
+    if (write(fd, buf, strlen(buf)) != strlen(buf)) {
+	close(fd);
+	return -1;
+    }
+
+    return close(fd);
+}
+
+int led_off(const char *led)
+{
+    int rv = 0;
+
+    rv |= led_write(led, "trigger", "none");
+    rv |= led_write(led, "brightness", "0");
+
+    return rv;
+}
+
+int led_blink_prepare(const char *led, unsigned int duration)
+{
+    char buffer[255];
+    int fd, rv = 0;
+
+    /* check whether we can enable the transient trigger for this led */
+    rv = led_is_trigger_missing(led);
+    if (rv != 0)
+	return rv;
+
+    /*
+     * switch to transient trigger, this will kick creation of additional
+     * property file in sysfs
+     */
+    rv = led_write(led, "trigger", "transient");
+    if (rv)
+	return rv;
+
+    /* wait until kernel managed to create the property files */
+    snprintf(buffer, sizeof(buffer), "%s/%s/state", SYSFS_LED_BASE, led);
+    while ((fd = open(buffer, O_RDONLY)) == -1);
+    close(fd);
+
+    snprintf(buffer, sizeof(buffer), "%s/%s/duration", SYSFS_LED_BASE, led);
+    while ((fd = open(buffer, O_RDONLY)) == -1);
+    close(fd);
+
+    /* pre-configure the trigger for our needs */
+    snprintf(buffer, sizeof(buffer), "%u", duration);
+    rv |= led_write(led, "state", "1");
+    rv |= led_write(led, "duration", buffer);
+    return rv;
+}
+
+int led_blink_kick(const char *led)
+{
+    return led_write(led, "activate", "1");
+}
+
+#endif /* USE_LED_FEATURE */
--- /dev/null
+++ b/sysfs_led.h
@@ -0,0 +1,11 @@
+/*
+ * Copyright (C) 2015 I2SE GmbH
+ */
+#ifndef SYSFS_LED_H
+#define SYSFS_LED_H
+
+int led_off(const char *led);
+int led_blink_prepare(const char *led, unsigned int duration);
+int led_blink_kick(const char *led);
+
+#endif /* SYSFS_LED_H */
--- a/utils.c
+++ b/utils.c
@@ -25,6 +25,9 @@
 #include <errno.h>
 #include <unistd.h>
 #include <fcntl.h>
+#include <time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
 
 #include "ser2net.h"
 #include "utils.h"
--- a/utils.h
+++ b/utils.h
@@ -64,6 +64,9 @@ char *find_tracefile(const char *name);
 /* Search for RS485 configuration by name. */
 struct serial_rs485 *find_rs485conf(const char *name);
 
+/* Search for a LED by name */
+char *find_led(const char *name);
+
 void check_ipv6_only(int family, struct sockaddr *addr, int fd);
 
 /* Make sure the full contents get written, return an error if it occurs. */
