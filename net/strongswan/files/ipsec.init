#!/bin/sh /etc/rc.common

EXTRA_COMMANDS="update reread"
EXTRA_HELP="        update  Update and apply configuration file
        reread  Reread and apply secrets file"

START=90
STOP=10
PROG="/usr/sbin/ipsec"

ORIGINAL_CONF_FILE="/etc/ipsec.conf"
ORIGINAL_SECRETS_FILE="/etc/ipsec.secrets"

GENERATED_CONF_FILE="/var/run/ipsec.conf"
GENERATED_SECRETS_FILE="/var/run/ipsec.secrets"

config_type="$1"
config_name="$2"
option_name="$1"
option_value="$2"
list_name="$1"
list_value="$2"

conn_entry_found=0

ListOpt=""
ListVals=""

DebugOpt=0
DebugVals=""

DbgId=""

config_cb() {
	config_type="$1"
	config_name="$2"

	# write out last list option (from last section) if exist and clear
	if [ "$ListOpt" != "" ]; then

		echo "        $ListOpt=$ListVals" >> $GENERATED_CONF_FILE
	fi

	ListOpt=""
	ListVals=""

	# write out debug options if setup section is completed
	if [ "$DebugOpt" -ne 0 ]; then

		echo "        charondebug=$DebugVals" >> $GENERATED_CONF_FILE
		DebugOpt=0
	fi

	[ "$config_type" = "secret" ] && return 0						#ignore 'secret' sections

	echo "$config_type $config_name" >> $GENERATED_CONF_FILE

	if [ "$config_type" = "conn" ]; then

		conn_entry_found=1

		if [ "$(uci_get ipsec "$config_name" leftupdown)" = "" -a "$(uci_get ipsec "$config_name" leftfirewall)" != "yes" ]; then
			echo "        leftupdown=/usr/lib/ipsec/_updown" >> $GENERATED_CONF_FILE
		fi
	fi
}

option_cb() {
	option_name="$1"
	option_value="$2"


	[ "$config_type" = "secret" ] && return 0						#ignore 'secret' sections
	[ "${option_name#*_ITEM}" != "$option_name" ]   && return 0				# ignore lists *_ITEM*
	[ "${option_name#*_LENGTH}" != "$option_name" ] && return 0				# ignore lists *_LENGTH
	[ "${option_name}" = "hotplugifc" ] && return 0						# ignore hotplugifc option
	[ "${option_name}" = "connflush" ] && return 0						# ignore option as it is used only internally and not a strongswan parameter

	# collect debug options for writing to config file
	if [ "$(echo "$option_name" | grep -c charondebug_)" -ne 0 ]; then

		if [ "$DebugVals" = "" ]; then

			DebugOpt=1
			DbgId=$(echo "$option_name" | sed -e 's/charondebug_//')
			DebugVals="$DbgId $option_value"
		else

			DbgId=$(echo "$option_name" | sed -e 's/charondebug_//')
			DebugVals="$DebugVals,$DbgId $option_value"
		fi
	else
		if [ "$option_value" = "${option_value// /}" ]
		then
			echo "        $option_name=$option_value" >> $GENERATED_CONF_FILE
		else
			echo "        $option_name=\"$option_value\"" >> $GENERATED_CONF_FILE
		fi
	fi
}

list_cb() {
	list_name="$1"
	list_value="$2"


	[ "$config_type" = "secret" ] && return 0						#ignore 'secret' sections

	# write out last list option if new list starts
	if [ "$ListOpt" != "" -a "$ListOpt" != "$list_name" ]; then

		echo "        $ListOpt=$ListVals" >> $GENERATED_CONF_FILE

		ListOpt=""
		ListVals=""

	fi

	# new list option
	if [ -z "$ListOpt" ]; then

		ListOpt="$list_name"
		ListVals="$list_value"
	else
		ListVals="$ListVals,$list_value"
	fi
}

secrets_add() {
	local cfg="$1"
	config_get type "$cfg" type
	config_get key_file "$cfg" key_file
	config_get id_selector "$cfg" id_selector
	config_get pass_secret "$cfg" pass_secret

	[ "$type" = "RSA" ] && echo ": RSA $key_file \"$pass_secret\"" >> $GENERATED_SECRETS_FILE
	[ "$type" = "PSK" ] && echo "$id_selector : PSK \"$pass_secret\"" >> $GENERATED_SECRETS_FILE
	[ "$type" = "EAP" ] && echo "$id_selector : EAP \"$pass_secret\"" >> $GENERATED_SECRETS_FILE
	[ "$type" = "XAUTH" ] && echo "$id_selector : XAUTH \"$pass_secret\"" >> $GENERATED_SECRETS_FILE
	[ "$type" = "P12" ] && echo ": P12 $key_file \"$pass_secret\"" >> $GENERATED_SECRETS_FILE
	[ "$type" = "ECDSA" ] && echo ": ECDSA $key_file \"$pass_secret\"" >> $GENERATED_SECRETS_FILE
	[ "$type" = "BLISS" ] && echo ": BLISS $key_file" >> $GENERATED_SECRETS_FILE
	[ "$type" = "NTLM" ] && echo "$id_selector : NTLM $pass_secret" >> $GENERATED_SECRETS_FILE
}

generate_config() {
	[ -f "$GENERATED_CONF_FILE" ] && rm -f "$GENERATED_CONF_FILE"
	[ -f "$GENERATED_SECRETS_FILE" ] && rm -f "$GENERATED_SECRETS_FILE"

	config_load ipsec
	config_foreach secrets_add secret

	# strongSwan doesn't allow to set a config file path' on command line, we have to use symlinks instead
	# (as the /var directory is in RAM, we don't have to write to FLASH each time -> lifetime for write cycles)
	if [ ! -f "$ORIGINAL_CONF_FILE" ] || ([ -f "$ORIGINAL_CONF_FILE" ] && [ ! -L "$ORIGINAL_CONF_FILE" ]); then
		rm "$ORIGINAL_CONF_FILE" >/dev/null 2>/dev/null
		ln -s "$GENERATED_CONF_FILE" "$ORIGINAL_CONF_FILE"
	fi

	if [ ! -f "$ORIGINAL_SECRETS_FILE" ] || ([ -f "$ORIGINAL_SECRETS_FILE" ] && [ ! -L "$ORIGINAL_SECRETS_FILE" ]); then
		rm "$ORIGINAL_SECRETS_FILE" >/dev/null 2>/dev/null
		ln -s "$GENERATED_SECRETS_FILE" "$ORIGINAL_SECRETS_FILE"
	fi
}

lock_service_ipsec() {
	mkdir -p /var/run
	lock /var/run/ipsec-init.lock
}

unlock_service_ipsec() {
	lock -u /var/run/ipsec-init.lock
}

start() {
	lock_service_ipsec
	generate_config
	if [ $conn_entry_found -eq 1 ]; then
		$PROG start
	else
		echo "no conn entry found, exiting"
	fi
	unlock_service_ipsec
}

stop() {
	lock_service_ipsec
	$PROG stop
	unlock_service_ipsec
}

restart() {
	lock_service_ipsec
	generate_config
	$PROG restart
	unlock_service_ipsec
}

reload() {
	lock_service_ipsec
	generate_config
	$PROG reload
	unlock_service_ipsec
}

update() {
	lock_service_ipsec
	generate_config
	$PROG update
	unlock_service_ipsec
}

reread() {
	lock_service_ipsec
	generate_config
	$PROG rereadsecrets
	unlock_service_ipsec
}
